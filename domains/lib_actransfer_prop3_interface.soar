#####	Author: Bryan Stearns, 2018
# Manage a buffer system in Soar working memory similar to Actransfer's, allowing use of PRIMs instructions
# Working memory has:
# <s> 	^G				# Goal buffer
#			^Gtask		#   If set to "finish", then reset the buffers
#			^clear-rt	#   If this exists, then clear the RT buffer results
#		^WM				# Working memory buffer
#			^slot[1,2,3,...]
#		^NW				# NewWM buffer
#			^wm			#   An individual newwm command (a new declarative 'chunk' to replace current WM contents)
#		^Q				# Query buffer
#			^query		#   An individual query command for smem
#			^wm-query	#   A query for an past declarative WM 'chunk' (object), still stored in working memory within the pointer network
#			^retrieve	#   A retrieve command for a specific WM 'chunk' (object), still stored in working memory
#		^RT				# Where Q results are placed
#		^AC				# The action buffer
#			^action		#   An individual action command
#		^V				# The input (visual) buffer
#			^Vlabel
#			^Vvalue
#####


# CHUNK SINGLETON COMMANDS ARE ESSENTIAL TO PREVENT CHUNKS MATCHING SEVERAL TIMES
chunk singleton identifier slot1 identifier
chunk singleton identifier slot2 identifier
chunk singleton identifier slot3 identifier
chunk singleton identifier slot4 identifier
chunk singleton identifier slot1 constant
chunk singleton identifier slot2 constant
chunk singleton identifier slot3 constant
chunk singleton identifier slot4 constant




#### SWITCH TO SECONDARY BEHAVIOR IN CASE OF LACK OF PROPS INSTRUCTIONS ####
# (IN THIS CASE, HALTING)
sp {lib*actr*instruction*search*impasse
	(state <s>	^superstate nil 
				^props-flag impasse)
-->
	(write |    Well, well, well. I see I've run out of instructions. Goodnight.| (crlf) )
	(halt)
}


#### INPUT ####

sp {lib*actr*elaborate*visual*in
	(state <s> ^V <v>
				^io.input-link <il>)
	(<il> ^<attr> <val>)
	-{(<s> ^locks.lock <l>)
	  (<l> ^id1 <v>
		   ^attr1 <attr>)}		# Locks defined in props_apply_buffer.soar
-->
	(<v> ^<attr> <val>)
	#(write |* Loading V.| <attr> | | <val> |  | )
}
sp {lib*actr*elaborate*visual*debug*in-1
	(state <s> ^V <v>
				^io.input-link <il>)
	(<il> ^slot1 <i1>
		-^slot2)
-->
	(write (crlf) |Read: "| <i1> |"|)
}
sp {lib*actr*elaborate*visual*debug*in-2
	(state <s> ^V <v>
				^io.input-link <il>)
	(<il> ^slot1 <i1>
		^slot2 <i2>
		-^slot3)
-->
	(write (crlf) |Read: "| <i1> |" "| <i2> |"|)
}
sp {lib*actr*elaborate*visual*debug*in-3
	(state <s> ^V <v>
				^io.input-link <il>)
	(<il> ^slot1 <i1>
		^slot2 <i2>
		^slot3 <i3>
		-^slot4)
-->
	(write (crlf) |Read: "| <i1> |" "| <i2> |" "| <i3> |"|)
}
sp {lib*actr*elaborate*visual*debug*in-4
	(state <s> ^V <v>
				^io.input-link <il>)
	(<il> ^slot1 <i1>
		^slot2 <i2>
		^slot3 <i3>
		^slot4 <i4>
		-^slot5)
-->
	(write (crlf) |Read: "| <i1> |" "| <i2> |" "| <i3> |" "| <i4> |"|)
}
sp {lib*actr*elaborate*visual*debug*in-5
	(state <s> ^V <v>
				^io.input-link <il>)
	(<il> ^slot1 <i1>
		^slot2 <i2>
		^slot3 <i3>
		^slot4 <i4>
		^slot5 <i5>)
-->
	(write (crlf) |Read: "| <i1> |" "| <i2> |" "| <i3> |" "| <i4> |" "| <i5> |"|)
}


# TRANSFER INPUT TO TASK SPECIFICATION
sp {lib*actr*elaborate*input*task
	(state <s> ^io.input-link <il>
			   ^G <g>)
	(<il> ^task <task>)
	(<g> -^Gtask finish)
	-{(<s> ^locks.lock <l>)
	  (<l> ^id1 <g>
		   ^attr1 Gtask)}		# Locks enabled using props_apply_buffer.soar
-->
	(<g> ^Gtask <task>)
	(write (crlf) |*** TASK SET TO | <task> | ***| )
}


### OUTPUT ###

sp {lib*actr*elaborate*action*out
	(state <s> ^AC.object <a>
				^io.output-link <ol>)
-->
	(<ol> ^say <a>)
}
sp {lib*actr*set*output*clean
    :o-support
    (state <s> ^io.output-link <ol>
                ^AC <a>)
    (<ol> ^say <os>)
    (<a> ^object <os>)
    (<os> ^status complete)
-->
    (<a> ^object <os> -)
}

# DEBUG PRINT OUTPUT: Assuming action slots follow certain format
sp {lib*actr*elaborate*action*output-1
	(state <s> ^AC.object <a>)
	(<a> ^slot1 <o1>
		-^slot2 <o2>)
-->
	(write (crlf) |Say: | <o1> (crlf) )
}
sp {lib*actr*elaborate*action*output-2
	(state <s> ^AC.object <a>)
	(<a> ^slot1 <o1>
		^slot2 <o2>
		-^slot3)
-->
	(write (crlf) |Say: | <o1> | | <o2> (crlf) )
}
sp {lib*actr*elaborate*action*output-3
	(state <s> ^AC.object <a>)
	(<a> ^slot1 <o1>
		^slot2 <o2>
		^slot3 <o3>
		-^slot4)
-->
	(write (crlf) |Say: | <o1> | | <o2> | | <o3> (crlf) )
}
sp {lib*actr*elaborate*action*output-4
	(state <s> ^AC.object <a>)
	(<a> ^slot1 <o1>
		^slot2 <o2>
		^slot3 <o3>
		^slot4 <o4>
		-^slot5)
-->
	(write (crlf) |Say: | <o1> | | <o2> | | <o3> | | <o4> (crlf) )
}
sp {lib*actr*elaborate*action*output-5
	(state <s> ^AC.object <a>)
	(<a> ^slot1 <o1>
		^slot2 <o2>
		^slot3 <o3>
		^slot4 <o4>
		^slot5 <o5>)
-->
	(write (crlf) |Say: | <o1> | | <o2> | | <o3> | | <o4> | | <o5> (crlf) )
}



### ADD WAIT OPERATOR BEHAVIOR ###

sp {lib*actr*propose*wait
	(state <s> ^topstate.io.input-link.slot1 |pending|
				-^operator.name |wait-pending|)
-->
	(<s> ^operator <o> + = <)
	(<o> ^name wait-pending)
}
sp {lib*actr*propose*idle
	(state <s> ^superstate.operator.name |wait|
				-^operator.name |wait-pending|)
-->
	(<s> ^operator <o> + > !)
	(<o> ^name wait-pending)
}
