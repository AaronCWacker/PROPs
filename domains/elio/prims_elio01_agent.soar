### RULES FOR ELIO TASK
#
## WM-LAYOUT
#
# CONTROL:
#	Gtask		The name of the current task
#	Gcontrol	The name of the current control state
#	Gtop		Pointer to WM chunk
#	Gparent		The name of the parent task
# INPUT:
#	Vlabel		Retracted when no input (instead of nil)
#	Vvalue		"
# WM:
#	WMatt
#	WMvalue
#	WMprev		Previous WM chunk
#	WMnext		Soar version: Next WM chunk
# RETRIEVAL:
#	RTtype/RTatt
#	RTarg1/RTvalue
#	RTarg2
#	RTans
# QUERY:
#	RTtype
#	RTarg1
#	RTarg2
# ACTION:
#	ACout1		Print word 1
#	ACout2		Print word 2
#
###

#source lib_actr_interface.soar
#source smem_elio.soar

#smem --set learning on


##### PROCEDURE-A #####
##  (add-instr procedure-a :input (Vlabel Vvalue) :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

##  At the start of the procedure A, save the current task name in Gparent, and put solid-lime-diff in the task
##  name. This switches control to the solid-lime-diff procedure (below). In addition, initialize the
##  declarative memory context by setting Gtop to the current working memory element.
# (ins :condition (Gtop = nil) :action (WMid -> Gtop Gtask -> Gparent solid-lime-diff -> Gtask) :description "Starting step 1 in procedure A")\\
sp {propose*elio*procedure-A*step-1
	(state <s> ^G <g>)
	(<g> ^Gtask procedure-a
		^Gtop nil)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-A-1)
}
sp {apply*elio*procedure-A*step-1
	(state <s> ^operator.name elio-A-1
		^WM <w>
		^G <g>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>
		^Gtop <gtop>)
-->
	(<g> ^Gtop <gtop> -
		^Gtop <w>
		^Gparent <gparent> -
		^Gparent <gtask>
		^Gtask <gtask> -
		^Gtask solid-lime-diff)
	#(write |# Starting step 1 in procedure A| (crlf))
}

##  When control is back to procedure A, the name of the calculated result is in WMatt, and the value in
##  WMvalue. WMvalue is typed into the system, after which the next step is initiated (greater-algae).
# (ins :condition (WMatt = solid-lime-diff) :action ((enter WMvalue) -> AC particulate -> WMatt (? ? WMid) -> newWM greater-algae -> Gtask) :description "Starting step 2 in procedure A")
sp {propose*elio*procedure-A*step-2
	(state <s> ^G.Gtask procedure-a
				^WM.slot1 solid-lime-diff)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-A-2)
}
sp {apply*elio*procedure-A*step-2
	(state <s> ^operator.name elio-A-2
				^WM <w>
				^NW <n>
				^AC <a>
				^G <g>)
	(<w> ^slot2 <wmvalue>
		^slot1 <wmatt>)
	(<g> ^Gtask <gtask>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |particulate|)
	(<n> ^slot1 nil
		^slot2 nil
		^slot3 <w>
		^slot4 nil)
	(<s> ^WM <w> -
		^WM <w2>)
	(<g> ^Gtask <gtask> -
		^Gtask |greater-algae|
		^clear-rt |enter|)
	#(write |# Starting step 2 in procedure A| (crlf))
}

# (ins :condition (WMatt = greater-algae) :action ((enter WMvalue) -> AC mineral -> WMatt part-plus-mineral -> Gtask) :description "Starting step 3 in procedure A")
sp {propose*elio*procedure-A*step-3
	(state <s> ^G.Gtask procedure-a
				^WM.slot1 greater-algae)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-A-3)
}
sp {apply*elio*procedure-A*step-3
	(state <s> ^operator.name elio-A-3
				^WM <w>
				^AC <a>
				^G <g>)
	(<w> ^slot2 <wmvalue>
		^slot1 <wmatt>)
	(<g> ^Gtask <gtask>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |mineral|)
	(<g> ^Gtask <gtask> -
		^Gtask |part-plus-mineral|
		^clear-rt |enter|)
	#(write |# Starting step 3 in procedure A| (crlf))
}

# (ins :condition (WMatt = part-plus-mineral) :action ((enter WMvalue) -> AC index1 -> WMatt (? ? WMid) -> newWM mean-toxin -> Gtask) :description "Starting step 4 in procedure A")
sp {propose*elio*procedure-A*step-4
	(state <s> ^G.Gtask procedure-a
				^WM.slot1 part-plus-mineral)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-A-4)
}
sp {apply*elio*procedure-A*step-4
	(state <s> ^operator.name elio-A-4
				^WM <w>
				^NW <n>
				^AC <a>
				^G <g>)
	(<w> ^slot2 <wmvalue>
		^slot1 <wmatt>
		^slot3 <wmprev>)
	(<g> ^Gtask <gtask>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |index1|)
	(<n> ^slot1 nil
		^slot2 nil
		^slot3 <wmprev>
		^slot4 nil)
	(<g> ^Gtask <gtask> -
		^Gtask |mean-toxin|
		^clear-rt |enter|)
	#(write |# Starting step 4 in procedure A| (crlf))
}

# (ins :condition (WMatt = mean-toxin) :action ((enter WMvalue) -> AC marine -> WMatt index1-div-marine -> Gtask) :description "Starting step 5 in procedure A")
sp {propose*elio*procedure-A*step-5
	(state <s> ^G.Gtask procedure-a
				^WM.slot1 mean-toxin)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-A-5)
}
sp {apply*elio*procedure-A*step-5
	(state <s> ^operator.name elio-A-5
				^WM <w>
				^AC <a>
				^G <g>)
	(<w> ^slot2 <wmvalue>
		^slot1 <wmatt>)
	(<g> ^Gtask <gtask>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |marine|)
	(<g> ^Gtask <gtask> -
		^Gtask |index1-div-marine|
		^clear-rt |enter|)
	#(write |# Starting step 5 in procedure A| (crlf))
}

# (ins :condition (WMatt = index1-div-marine) :action ((enter WMvalue) -> AC index2 -> WMatt index2-min-mineral -> Gtask) :description "Starting step 6 in procedure A")
sp {propose*elio*procedure-A*step-6
	(state <s> ^G.Gtask procedure-a
				^WM.slot1 index1-div-marine)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-A-6)
}
sp {apply*elio*procedure-A*step-6
	(state <s> ^operator.name elio-A-6
				^WM <w>
				^AC <a>
				^G <g>)
	(<w> ^slot2 <wmvalue>
		^slot1 <wmatt>)
	(<g> ^Gtask <gtask>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |index2|)
	(<g> ^Gtask <gtask> -
		^Gtask |index2-min-mineral|
		^clear-rt |enter|)
	#(write |# Starting step 6 in procedure A| (crlf))
}

# (ins :condition (WMatt = index2-min-mineral) :action ((enter WMvalue) -> AC finish -> Gtask) :description "Entering last result and finishing procedure A")
sp {propose*elio*procedure-A*step-7
	(state <s> ^G.Gtask procedure-a
				^WM.slot1 index2-min-mineral)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-A-7)
}
sp {apply*elio*procedure-A*step-7
	(state <s> ^operator.name elio-A-7
				^WM <w>
				^AC <a>
				^G <g>)
	(<w> ^slot2 <wmvalue>)
	(<g> ^Gtask <gtask>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<g> ^Gtask <gtask> -
		^Gtask |finish|
		^clear-rt |enter|)
	#(write |# Entering last result and finishing procedure A| (crlf))
}


##### SOLID-LIME-DIFF #####
##  (add-instr solid-lime-diff :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))
##  Other stuff is inherited from main goal

##  This procedure reads the appropriate information from the screen and performs the calculation solid x (lime 4 â€“ lime 2 )
##  If Vlabel is still nil, this means the model is at the start of the subtask, so it will begin by looking up the value of lime 4 on the screen.
##  The (read label) action looks up the requested value, and puts the label name in Vlabel and the label value in Vvalue.
##  The next operator is retrieved when lime 4 has been read.
# (ins :condition (Vlabel = nil) :action ( (read lime4) -> AC ) :description "Entering solid-lime-diff, reading lime4")
sp {propose*elio*solid-lime-diff*step-1
	(state <s> ^G.Gtask solid-lime-diff
				-^V.Vlabel)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-sld-1)
}
sp {apply*elio*solid-lime-diff*step-1
	(state <s> ^operator.name elio-sld-1
				^AC <a>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |lime4|)
	#(write |# Entering solid-lime-diff, reading lime4| (crlf))
}

##  The action of this operator stores the value of lime 4 in WM, and reads lime 2.
# (ins :condition (Vlabel = lime4) :action (Vvalue -> WMvalue (read lime2) -> AC) :description "Reading lime2")
sp {propose*elio*solid-lime-diff*step-2
	(state <s> ^G.Gtask solid-lime-diff
				^V.Vlabel lime4)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-sld-2)
}
sp {apply*elio*solid-lime-diff*step-2
	(state <s> ^operator.name elio-sld-2
				^WM <w>
				^V <v>
				^AC <a>)
	(<v> ^Vvalue <vvalue>)
	(<w> ^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <vvalue>)
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |lime2|)
	#(write |# Solid-lime-diff: reading lime2| (crlf))
}

##   This operator checks whether lime 2 has been read, but also checks one of the retrieval slots.
##  This nil-check on the retrieval is used fairly often before initiating a retrieval.
##  It ensures the same operator is not carried out again after the retrieval is successful.
##   The action of this operator is to retrieve a fact with subtract in slot1, the value in WM in slot2, and the value in the input in slot3.
##  In other words, it determines the difference between lime 4 and lime 2 .
##  It also reads the value of solid.
# (ins :condition (RT1 = nil   Vlabel = lime2) :action ((subtract WMvalue Vvalue) -> RT (read solid) -> AC) :description "Calculating the difference and reading Solid")
sp {propose*elio*solid-lime-diff*diff
	(state <s> 	^G.Gtask solid-lime-diff
				^RT.slot1 nil #-^RT.slot1
				^V.Vlabel lime2)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-sld-diff)
}
sp {apply*elio*solid-lime-diff*diff
	(state <s> ^operator.name elio-sld-diff
				^WM <w>
				^V <v>
				^Q <q>
				^AC <a>)
	(<w> ^slot2 <wmvalue>)
	(<v> ^Vvalue <vvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<q> ^slot1 |subtract|
		^slot2 <wmvalue>
		^slot3 <vvalue>)
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |solid|)
	#(write |# Calculating the difference and reading Solid| (crlf))
}

##  Once the difference is retrieved and the value of solid is determined, this operator retrieves the product of the two.
# (ins :condition (RTtype = subtract  Vlabel = solid ) :action ((mult Vvalue RTans) -> RT) :description "Multiplying the result by Solid")
sp {propose*elio*solid-lime-diff*mult
	(state <s> 	^G.Gtask solid-lime-diff
				^RT.slot1 subtract
				^V.Vlabel solid)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-sld-mult)
}
sp {apply*elio*solid-lime-diff*mult
	(state <s> ^operator.name elio-sld-mult
				^RT <r>
				^Q <q>
				^V <v>)
	(<v> ^Vvalue <vvalue>)
	(<r> ^slot4 <rtans>)
-->
	(<q> ^slot1 |mult|
		^slot2 <vvalue>
		^slot3 <rtans>)
	#(write |# Multiplying the result by Solid| (crlf))
}

##  At the end of the calculation, put the result in WMinter, and put the main task back in the task slot in the goal
##  The result is placed in WM, so that the main goal knows what has been calculated.
##  The final action (Gparentâ€“>Gtask) restores the main goal.
# (ins :condition (RTtype = mult) :action (solid-lime-diff -> WMatt RTans -> WMvalue Gparent -> Gtask) :description "Finishing solid-lime-diff"))
sp {propose*elio*solid-lime-diff*finish
	(state <s> 	^G.Gtask solid-lime-diff
				^RT.slot1 mult)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-sld-finish)
}
sp {apply*elio*solid-lime-diff*finish
	(state <s> ^operator.name elio-sld-finish
				^RT.slot4 <rtans>
				^G <g>
				^WM <w>)
	(<w> ^slot2 <wmvalue>
		^slot1 <wmatt>)
	(<g> ^Gtask <gtask>
		^Gparent <gparent>)
-->
	(<w> ^slot1 <wmatt> -
		^slot1 |solid-lime-diff|
		^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Finishing solid-lime-diff| (crlf))
}

##### GREATER-ALGAE #####  
## (add-instr greater-algae :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (Vlabel = nil) :action ( (read algae) -> AC) :description "Entering greater-algae, reading Algae")
sp {propose*elio*greater-algae*start
	(state <s> 	^G.Gtask greater-algae
				-^V.Vlabel)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-greater-algae-start)
}
sp {apply*elio*greater-algae*start
	(state <s> ^operator.name elio-greater-algae-start
				^AC <a>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |algae|)
	#(write |# Entering greater-algae, reading Algae| (crlf))
}

# (ins :condition (RT1 = nil Vlabel = algae) :action ((div Vvalue 2) -> RT) :description "Dividing algae by 2")
sp {propose*elio*greater-algae*div-2
	(state <s> 	^G.Gtask greater-algae
				^RT.slot1 nil #-^RT.slot1
				^V.Vlabel algae)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-greater-algae-div-2)
}
sp {apply*elio*greater-algae*div-2
	(state <s> ^operator.name elio-greater-algae-div-2
				^Q <q>
				^V.Vvalue <vvalue>)
-->
	(<q> ^slot1 |div|
		^slot2 <vvalue>
		^slot3 2)
	#(write |# Dividing algae by 2| (crlf))
}

# (ins :condition (RTans <> nil Vlabel = algae) :action (RTans -> WMvalue (read solid) -> AC) :description "Reading solid")
sp {propose*elio*greater-algae*read-solid
	(state <s> 	^G.Gtask greater-algae
				^RT.slot4 <> nil
				^V.Vlabel algae)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-greater-algae-read-solid)
}
sp {apply*elio*greater-algae*read-solid
	(state <s> ^operator.name elio-greater-algae-read-solid
				^RT <r>
				^G <g>
				^WM <w>
				^AC <a>)
	(<r> ^slot4 <rtans>)
	(<w> ^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |solid|)
	(<g> ^clear-rt |read|)
	#(write |# Reading solid| (crlf))
}

# (ins :condition (RT1 = nil Vlabel = solid) :action ((div Vvalue 3) -> RT) :description "Dividing solid by 3")
sp {propose*elio*greater-algae*div-3
	(state <s> 	^G.Gtask greater-algae
				^RT.slot1 nil #-^RT.slot1
				^V.Vlabel solid)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-greater-algae-div-3)
}
sp {apply*elio*greater-algae*div-3
	(state <s> ^operator.name elio-greater-algae-div-3
				^Q <q>
				^V.Vvalue <vvalue>)
-->
	(<q> ^slot1 |div|
		^slot2 <vvalue>
		^slot3 3)
	#(write |# Dividing algae by 3| (crlf))
}

# (ins :condition (RTtype = div Vlabel = solid) :action ((greater-of WMvalue RTans) -> RT) :description "Determining the greater of the two")
sp {propose*elio*greater-algae*greater
	(state <s> 	^G.Gtask greater-algae
				^RT.slot1 div
				^V.Vlabel solid)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-greater-algae-greater)
}
sp {apply*elio*greater-algae*greater
	(state <s> ^operator.name elio-greater-algae-greater
				^WM <w>
				^Q <q>
				^RT <r>)
	(<w> ^slot2 <wmvalue>)
	(<r> ^slot4 <rtans>)
-->
	(<q> ^slot1 |greater-of|
		^slot2 <wmvalue>
		^slot3 <rtans>)
	#(write |# Determining the greater of the two| (crlf))
}

# (ins :condition (RTtype = greater-of) :action (greater-algae -> WMatt RTans -> WMvalue Gparent -> Gtask) :description "Finishing up greater-algae"))
sp {propose*elio*greater-algae*finish
	(state <s> 	^G.Gtask greater-algae
				^RT.slot1 greater-of
				^V.Vlabel solid)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-greater-algae-finish)
}
sp {apply*elio*greater-algae*finish
	(state <s> ^operator.name elio-greater-algae-finish
				^G <g>
				^WM <w>
				^RT <r>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<r> ^slot4 <rtans>)
-->
	(<w> ^slot1 <wmatt> -
		^slot1 |greater-algae|
		^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Finishing up greater-algae| (crlf))
}


##### PART-PLUS-MINERAL #####  
## (add-instr part-plus-mineral :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (RT1 = nil) :action ( Gtop -> RTid) :description "Enter part-plus-mineral, retrieving top WM item")
sp {propose*elio*part-plus-mineral*start
	(state <s> 	^G.Gtask part-plus-mineral
				^RT.slot1 nil) #-^RT.slot1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-part-plus-mineral-start)
}
sp {apply*elio*part-plus-mineral*start
	(state <s> ^operator.name elio-part-plus-mineral-start
				^G.Gtop <gtopID>
				^Q <q>)
	(<gtopID> ^slot1 <wmatt>
			^slot2 <wmvalue>
			^slot3 <wmprev>
			^slot4 <wmnext>)
-->
	(<q> ^slot1 <wmatt>
		^slot2 <wmvalue>
		^slot3 <wmprev>
		^slot4 <wmnext>)
	#(write |# Enter part-plus-mineral, retrieving top WM item| (crlf))
}

# (ins :condition (RTatt = particulate) :action ((add RTvalue WMvalue) -> RT WMid -> Gtop) :description "Add the retrieved particulate to stored Mineral & Store mineral as new top")
sp {propose*elio*part-plus-mineral*add
	(state <s> 	^G.Gtask part-plus-mineral
				^RT.slot1 particulate)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-part-plus-mineral-add)
}
sp {apply*elio*part-plus-mineral*add
	(state <s> ^operator.name elio-part-plus-mineral-add
				^G <g>
				^Q <q>
				^RT <r>
				^WM <w>)
	(<r> ^slot2 <arg1>)
	(<q> -^slot1)			# Prevent rule from applying twice over (replacing Gtop)
	(<g> ^Gtop <gtop>)
	(<w> ^slot2 <wmvalue>)
-->
	(<q> ^slot1 |add|
		^slot2 <arg1>
		^slot3 <wmvalue>)
	(<g> ^Gtop <gtop> -
		^Gtop <w>
		^clear-rt |add|)
	#(write |# Add the retrieved particulate to stored Mineral & Store mineral as new top| (crlf))
}

# (ins :condition (RTtype = add) :action ((part-plus-mineral RTans WMid) -> newWM  Gparent -> Gtask) :description "Finishing up part-plus-mineral"))
sp {propose*elio*part-plus-mineral*finish
	(state <s> 	^G.Gtask part-plus-mineral
				^RT.slot1 add)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-part-plus-mineral-finish)
}
sp {apply*elio*part-plus-mineral*finish
	(state <s> ^operator.name elio-part-plus-mineral-finish
				^G <g>
				^RT <r>
				^NW <n>
				^WM <w>)
	(<g> ^Gtask <gtask>
		^Gparent <gparent>)
	(<n> -^slot1)
	(<r> ^slot4 <rtans>)
-->
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	(<n> ^slot1 |part-plus-mineral|
		^slot2 <rtans>
		^slot3 <w>
		^slot4 nil)
	#(write |# Finishing up part-plus-mineral| (crlf))
}


##### MEAN-TOXIN #####  
## (add-instr mean-toxin :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (Vlabel = nil) :action ((read toxinmax) -> AC) :description "Entering mean-toxin, determining toxinmax")
sp {propose*elio*mean-toxin*start
	(state <s> 	^G.Gtask mean-toxin
				-^V.Vlabel)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-mean-toxin-start)
}
sp {apply*elio*mean-toxin*start
	(state <s> ^operator.name elio-mean-toxin-start
				^AC <a>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |toxinmax|)
	#(write |# Entering mean-toxin, determining toxinmax| (crlf))
}

# (ins :condition (Vlabel = toxinmax) :action (Vvalue -> WMvalue (read toxinmin) -> AC) :description "Determining toxinmin")
sp {propose*elio*mean-toxin*toxinmin
	(state <s> 	^G.Gtask mean-toxin
				^V.Vlabel toxinmax)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-mean-toxin-toxinmin)
}
sp {apply*elio*mean-toxin*toxinmin
	(state <s> ^operator.name elio-mean-toxin-toxinmin
				^WM <w>
				^V <v>
				^AC <a>)
	(<v> ^Vvalue <vvalue>)
	(<w> ^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <vvalue>)
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |toxinmin|)
	#(write |# Determining toxinmin| (crlf))
}

# (ins :condition (RT1 = nil Vlabel = toxinmin) :action ((add WMvalue Vvalue) -> RT) :description "Add them to each other")
sp {propose*elio*mean-toxin*add
	(state <s> 	^G.Gtask mean-toxin
				^RT.slot1 nil #-^RT.slot1
				^V.Vlabel toxinmin)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-mean-toxin-add)
}
sp {apply*elio*mean-toxin*add
	(state <s> ^operator.name elio-mean-toxin-add
				^WM <w>
				^V <v>
				^Q <q>)
	(<v> ^Vvalue <vvalue>)
	(<w> ^slot2 <wmvalue>)
-->
	(<q> ^slot1 |add|
		^slot2 <wmvalue>
		^slot3 <vvalue>)
	#(write |# Add them to each other| (crlf))
}

# (ins :condition (RTtype = add) :action ((div RTans 2) -> RT) :description "Divide the result by 2")
sp {propose*elio*mean-toxin*divide
	(state <s> 	^G.Gtask mean-toxin
				^RT.slot1 add)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-mean-toxin-divide)
}
sp {apply*elio*mean-toxin*divide
	(state <s> ^operator.name elio-mean-toxin-divide
				^Q <q>
				^RT <r>)
	(<r> ^slot4 <rtans>)
-->
	(<q> ^slot1 |div|
		^slot2 <rtans>
		^slot3 2)
	#(write |# Divide the result by 2| (crlf))
}

# (ins :condition (RTtype = div) :action (mean-toxin -> WMatt RTans -> WMvalue Gparent -> Gtask) :description "Finishing up Mean Toxin"))
sp {propose*elio*mean-toxin*finish
	(state <s> 	^G.Gtask mean-toxin
				^RT.slot1 div)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-mean-toxin-finish)
}
sp {apply*elio*mean-toxin*finish
	(state <s> ^operator.name elio-mean-toxin-finish
				^G <g>
				^RT <r>
				^WM <w>)
	(<g> ^Gtask <gtask>
		^Gparent <gparent>)
	(<r> ^slot4 <rtans>)
	(<w> ^slot2 <wmvalue>
		^slot1 <wmatt>)
-->
	(<w> ^slot1 <wmatt> -
		^slot1 |mean-toxin|
		^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Finishing up Mean Toxin| (crlf))
}


##### INDEX1-DIV-MARINE #####  
## (add-instr index1-div-marine input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (RT1 = nil) :action (Gtop -> RTid) :description "Entering Index1-div-marine, retrieving top DM item")
sp {propose*elio*index1-div-marine*start
	(state <s> 	^G.Gtask index1-div-marine
				^RT.slot1 nil) #-^RT.slot1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index1-div-marine-start)
}
sp {apply*elio*index1-div-marine*start
	(state <s> ^operator.name elio-index1-div-marine-start
				^G.Gtop <gtopID>
				^Q <q>)
	(<gtopID> ^slot1 <wmatt>
				^slot2 <wmvalue>
				^slot3 <wmprev>
				^slot4 <wmnext>)
-->
	(<q> ^slot1 <wmatt>
		^slot2 <wmvalue>
		^slot3 <wmprev>
		^slot4 <wmnext>)
	#(write |# Entering Index1-div-marine, retrieving top DM item| (crlf))
}

# (ins :condition (RTatt = mineral) :action (RTid -> RTprev)  :description "If retrieved item is not index1 then retrieve next")
sp {propose*elio*index1-div-marine*next
	(state <s> 	^G.Gtask index1-div-marine
				^RT.slot1 mineral)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index1-div-marine-next)
}
sp {apply*elio*index1-div-marine*next
	(state <s> ^operator.name elio-index1-div-marine-next
				^Q <q>
				^RT <r>)
	(<r> 	^slot4 <rn>)
	(<rn> ^slot1 <n1>		# Instead of querying, follow the WMnext pointer and fill RT with the result
			^slot2 <n2>
			^slot3 <n3>
			^slot4 <n4>)
-->
	(<q> ^slot1 <n1>
		^slot2 <n2>
		^slot3 <n3>
		^slot4 <n4>)
	#(write |# If retrieved item is not index1 then retrieve next| (crlf))
}

# (ins :condition (RTatt = index1) :action ((div RTvalue WMvalue) -> RT) :description "If it is index1 then divide it by marine which is still in WM")
sp {propose*elio*index1-div-marine*divide
	(state <s> 	^G.Gtask index1-div-marine
				^RT.slot1 index1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index1-div-marine-divide)
}
sp {apply*elio*index1-div-marine*divide
	(state <s> ^operator.name elio-index1-div-marine-divide
				^WM <w>
				^Q <q>
				^G <g>
				^RT <r>)
	(<r> ^slot2 <arg1>)
	(<w> ^slot2 <wmvalue>)
-->
	(<q> ^slot1 |div|	# RTvalue is RTarg1
		^slot2 <arg1>
		^slot3 <wmvalue>)
	(<g> ^clear-rt |div|)
	#(write |# If it is index1 then divide it by marine which is still in WM| (crlf))
}

# (ins :condition (RTtype = div) :action (index1-div-marine -> WMatt RTans -> WMvalue Gparent -> Gtask) :description "Finishing up index1-div-marine"))
sp {propose*elio*index1-div-marine*finish
	(state <s> 	^G.Gtask index1-div-marine
				^RT.slot1 div)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index1-div-marine-finish)
}
sp {apply*elio*index1-div-marine*finish
	(state <s> ^operator.name elio-index1-div-marine-finish
				^WM <w>
				^RT <r>
				^G <g>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<r> 	^slot4 <rtans>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
-->
	(<w> ^slot1 <wmatt> -
		^slot1 |index1-div-marine|
		^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Finishing up index1-div-marine| (crlf))
}


##### INDEX2-MIN-MINERAL #####  
## (add-instr index2-min-mineral input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (RT1 = nil) :action (Gtop -> RTid) :description "Entering Index2-min-mineral, retrieving top DM item")
sp {propose*elio*index2-min-mineral*start
	(state <s> 	^G.Gtask index2-min-mineral
				^RT.slot1 nil) #-^RT.slot1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index2-min-mineral-start)
}
sp {apply*elio*index2-min-mineral*start
	(state <s> ^operator.name elio-index2-min-mineral-start
				^Q <q>
				^G.Gtop <gtopID>)
	(<gtopID> ^slot1 <wmatt>
			^slot2 <wmvalue>
			^slot3 <wmprev>
			^slot4 <wmnext>)
-->
	(<q> ^slot1 <wmatt>
		^slot2 <wmvalue>
		^slot3 <wmprev>
		^slot4 <wmnext>)
	#(write |# Entering Index2-min-mineral, retrieving top DM item| (crlf))
}

# (ins :condition (RTatt = mineral) :action ((subtract WMvalue RTvalue) -> RT) :description "Subtract stored Index2 from the retrieved mineral")
sp {propose*elio*index2-min-mineral*subtract
	(state <s> 	^G.Gtask index2-min-mineral
				^RT.slot1 mineral)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index2-min-mineral-subtract)
}
sp {apply*elio*index2-min-mineral*subtract
	(state <s> ^operator.name elio-index2-min-mineral-subtract
				^RT <r>
				^Q <q>
				^G <g>
				^WM <w>)
	(<r> 	^slot2 <arg1>)
	(<w> ^slot2 <wmvalue>)
-->
	(<q> ^slot1 |subtract|
		^slot2 <wmvalue>
		^slot3 <arg1>)
	(<g> ^clear-rt |subtract|)
	#(write |# Subtract stored Index2 from the retrieved mineral| (crlf))
}

# (ins :condition (RTtype = subtract) :action (index2-min-mineral -> WMatt RTans -> WMvalue Gparent -> Gtask) :description "Finishing up index2-min-mineral"))
sp {propose*elio*index2-min-mineral*finish
	(state <s> 	^G.Gtask index2-min-mineral
				^RT.slot1 subtract)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index2-min-mineral-finish)
}
sp {apply*elio*index2-min-mineral*finish
	(state <s> ^operator.name elio-index2-min-mineral-finish
				^G <g>
				^RT <r>
				^WM <w>)
	(<r> 	^slot4 <rtans>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<g> ^Gtask <gtask>
		^Gparent <gparent>)
-->
	(<w> ^slot1 <wmatt> -
		^slot1 |index2-min-mineral|
		^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Finishing up index2-min-mineral| (crlf))
}


##### MINERAL-DIV-MARINE #####  
## (add-instr mineral-div-marine :input (Vlabel Vvalue) :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (RT1 = nil) :action ( Gtop -> RTid) :description "Entering mineral-div-marine, retrieving top DM item")
sp {propose*elio*mineral-div-marine*start
	(state <s> 	^G.Gtask mineral-div-marine
				^RT.slot1 nil) #-^RT.slot1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-mineral-div-marine-start)
}
sp {apply*elio*mineral-div-marine*start
	(state <s> ^operator.name elio-mineral-div-marine-start
				^Q <q>
				^G.Gtop <gtopID>)
	(<gtopID> ^slot1 <wmatt>
			^slot2 <wmvalue>
			^slot3 <wmprev>
			^slot4 <wmnext>)
-->
	(<q> ^slot1 <wmatt>
		^slot2 <wmvalue>
		^slot3 <wmprev>
		^slot4 <wmnext>)
	#(write |# Entering mineral-div-marine, retrieving top DM item| (crlf))
}

# (ins :condition (RTatt = particulate) :action ( (mineral ? RTid) -> RT) :description "Found particulate,  move on")
sp {propose*elio*mineral-div-marine*skip
	(state <s> 	^G.Gtask mineral-div-marine
				^RT.slot1 particulate)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-mineral-div-marine-skip)
}
sp {apply*elio*mineral-div-marine*skip
	(state <s> ^operator.name elio-mineral-div-marine-skip
				^RT <r>
				^Q <q>)
	(<r> ^slot4 <wmnext>)
	(<wmnext> ^slot1 <n1>
				^slot2 <n2>
				^slot3 <n3>
				^slot4 <n4>)
-->
	# Fill the retrieval result manually using the WMnext pointer
	(<q> ^slot1 <n1>
		^slot2 <n2>
		^slot3 <n3>
		^slot4 <n4>)
	#(write |# Found particulate,  move on| (crlf))
}

# (ins :condition (RTatt = mineral) :action ((div RTvalue WMvalue) -> RT) :description "Found mineral, enter it in the division")
sp {propose*elio*mineral-div-marine*divide
	(state <s> 	^G.Gtask mineral-div-marine
				^RT.slot1 mineral)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-mineral-div-marine-divide)
}
sp {apply*elio*mineral-div-marine*divide
	(state <s> ^operator.name elio-mineral-div-marine-divide
				^WM <w>
				^Q <q>
				^G <g>
				^RT <r>)
	(<r> ^slot2 <arg1>)
	(<w> ^slot2 <wmvalue>)
-->
	(<q> ^slot1 |div|
		^slot2 <arg1>
		^slot3 <wmvalue>)
	(<g> ^clear-rt |div|)
	#(write |# Found mineral, enter it in the division| (crlf))
}

# (ins :condition (RTtype = div) :action (mineral-div-marine -> WMatt RTans -> WMvalue Gparent -> Gtask) :description "Finishing up mineral-div-marine"))
sp {propose*elio*mineral-div-marine*finish
	(state <s> 	^G.Gtask mineral-div-marine
				^RT.slot1 div)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-mineral-div-marine-finish)
}
sp {apply*elio*mineral-div-marine*finish
	(state <s> ^operator.name elio-mineral-div-marine-finish
				^G <g>
				^RT <r>
				^WM <w>)
	(<r> 	^slot4 <rtans>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<g> ^Gtask <gtask>
		^Gparent <gparent>)
-->
	(<w> ^slot1 <wmatt> -
		^slot1 |mineral-div-marine|
		^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Finishing up mineral-div-marine| (crlf))
}


##### PART-MULT-INDEX1 #####  
## (add-instr part-mult-index1 :input (Vlabel Vvalue) :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (RT1 = nil) :action ( Gtop -> RTid) :description "Entering part-mult-index1, retrieving top DM item")
sp {propose*elio*part-mult-index1*start
	(state <s> 	^G.Gtask part-mult-index1
				^RT.slot1 nil) #-^RT.slot1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-part-mult-index1-start)
}
sp {apply*elio*part-mult-index1*start
	(state <s> ^operator.name elio-part-mult-index1-start
				^Q <q>
				^G.Gtop <gtopID>)
	(<gtopID> ^slot1 <wmatt>
			^slot2 <wmvalue>
			^slot3 <wmprev>
			^slot4 <wmnext>)
-->
	(<q> ^slot1 <wmatt>
		^slot2 <wmvalue>
		^slot3 <wmprev>
		^slot4 <wmnext>)
	#(write |# Entering part-mult-index1, retrieving top DM item| (crlf))
}

# (ins :condition (RTatt = particulate) :action ((mult RTvalue WMvalue) -> RT WMid -> Gtop (part-mult-index1) -> newWM) :description "Multiplying, and index1 is new top")
sp {propose*elio*part-mult-index1*mult
	(state <s> 	^G.Gtask part-mult-index1
				^RT.slot1 particulate)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-part-mult-index1-mult)
}
sp {apply*elio*part-mult-index1*mult
	(state <s> ^operator.name elio-part-mult-index1-mult
				^WM <w>
				^NW <n>
				^RT <r>
				^Q <q>
				^G <g>)
	(<r> ^slot2 <arg1>)
	(<n> -^slot1)			# needed because will apply twice otherwise, and query will be corrupted
	(<g> ^Gtop <gtop>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
-->
	(<q> ^slot1 |mult|
		^slot2 <arg1>
		^slot3 <wmvalue>)
	(<g> ^Gtop <gtop> -
		^Gtop <w>
		^clear-rt |mult|)
	(<n> ^slot1 |part-mult-index1|
		^slot2 nil
		^slot3 nil
		^slot4 nil)
	#(write |# Multiplying, and index1 is new top| (crlf))
}

# (ins :condition (RTtype = mult) :action (RTans -> WMvalue Gparent -> Gtask)))
sp {propose*elio*part-mult-index1*finish
	(state <s> 	^G.Gtask part-mult-index1
				^RT.slot1 mult)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-part-mult-index1-finish)
}
sp {apply*elio*part-mult-index1*finish
	(state <s> ^operator.name elio-part-mult-index1-finish
				^G <g>
				^RT <r>
				^WM <w>)
	(<r> 	^slot4 <rtans>)
	(<w> ^slot2 <wmvalue>)
	(<g> ^Gtask <gtask>
		^Gparent <gparent>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Finishing up part-mult-index1| (crlf))
}


##### INDEX1-PLUS-INDEX2 #####  
## (add-instr index1-plus-index2 :input (Vlabel Vvalue) :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (RT1 = nil) :action ( Gtop -> RTid) :description "Entering index1-plus-index2, retrieving top DM item")
sp {propose*elio*index1-plus-index2*start
	(state <s> 	^G.Gtask index1-plus-index2
				^RT.slot1 nil) #-^RT.slot1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index1-plus-index2-start)
}
sp {apply*elio*index1-plus-index2*start
	(state <s> ^operator.name elio-index1-plus-index2-start
				^Q <q>
				^G.Gtop <gtopID>)
	(<gtopID> ^slot1 <wmatt>
			^slot2 <wmvalue>
			^slot3 <wmprev>
			^slot4 <wmnext>)
-->
	(<q> ^slot1 <wmatt>
		^slot2 <wmvalue>
		^slot3 <wmprev>
		^slot4 <wmnext>)
	#(write |# Entering index1-plus-index2, retrieving top DM item| (crlf))
}

#(ins :condition (RTatt = index1) :action ((add WMvalue RTvalue) -> RT))
sp {propose*elio*index1-plus-index2*add
	(state <s> 	^G.Gtask index1-plus-index2
				^RT.slot1 index1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index1-plus-index2-add)
}
sp {apply*elio*index1-plus-index2*add
	(state <s> ^operator.name elio-index1-plus-index2-add
				^WM <w>
				^Q <q>
				^G <g>
				^RT <r>)
	(<r> 	^slot2 <arg1>)
	(<w> ^slot2 <wmvalue>)
-->
	(<q> ^slot1 |add|
		^slot2 <wmvalue>
		^slot3 <arg1>)
	(<g> ^clear-rt |add|)
	#(write |#  Found index, enter it in the addition| (crlf))
}

# (ins :condition (RTtype = add) :action (index1-plus-index2 -> WMatt RTans -> WMvalue Gparent -> Gtask)))
sp {propose*elio*index1-plus-index2*finish
	(state <s> 	^G.Gtask index1-plus-index2
				^RT.slot1 add)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-index1-plus-index2-finish)
}
sp {apply*elio*index1-plus-index2*finish
	(state <s> ^operator.name elio-index1-plus-index2-finish
				^G <g>
				^RT <r>
				^WM <w>)
	(<r> 	^slot4 <rtans>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<g> ^Gtask <gtask>
		^Gparent <gparent>)
-->
	(<w> ^slot1 <wmatt> -
		^slot1 |index1-plus-index2|
		^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Finishing up index1-plus-index2| (crlf))
}



##### PROCEDURE-B #####  
## (add-instr procedure-b :input (Vlabel Vvalue) :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (Gtop = nil) :action (WMid -> Gtop Gtask -> Gparent mean-toxin -> Gtask) :description "Starting step 1 in procedure B")
sp {propose*elio*procedure-b*start
	(state <s> 	^G <g>)
	(<g> ^Gtask procedure-b
			^Gtop nil)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-b-start)
}
sp {apply*elio*procedure-b*start
	(state <s> ^operator.name elio-procedure-b-start
				^WM <w>
				^G <g>)
	(<g> ^Gtop <gtop>
		^Gparent <gparent>
		^Gtask <gtask>)
-->
	(<g> ^Gtop <gtop> -
		^Gtop <w>
		^Gparent <gparent> -
		^Gparent <gtask>
		^Gtask <gtask> -
		^Gtask |mean-toxin|)
	#(write |# Starting step 1 in procedure B| (crlf))
}

# (ins :condition (WMatt = mean-toxin) :action ((enter WMvalue) -> AC particulate -> WMatt (? ? WMid) -> newWM solid-lime-diff -> Gtask) :description "Starting step 2 in procedure B")
sp {propose*elio*procedure-b*step-2
	(state <s> 	^G.Gtask procedure-b
				^WM.slot1 mean-toxin)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-b-step-2)
}
sp {apply*elio*procedure-b*step-2
	(state <s> ^operator.name elio-procedure-b-step-2
				^WM <w>
				^NW <n>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |particulate|)
	(<n> ^slot1 nil
		^slot2 nil
		^slot3 <w>
		^slot4 nil)
	(<g> ^Gtask <gtask> -
		^Gtask |solid-lime-diff|
		^clear-rt |enter|)
	#(write |# Starting step 2 in procedure B| (crlf))
}

# (ins :condition (WMatt = solid-lime-diff) :action ((enter WMvalue) -> AC mineral -> WMatt (? ? WMid) -> newWM greater-algae -> Gtask) :description "Starting step 3 in procedure B")
sp {propose*elio*procedure-b*step-3
	(state <s> 	^G.Gtask procedure-b
				^WM.slot1 solid-lime-diff)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-b-step-3)
}
sp {apply*elio*procedure-b*step-3
	(state <s> ^operator.name elio-procedure-b-step-3
				^WM <w>
				^NW <n>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |mineral|)
	(<n> ^slot1 nil
		^slot2 nil
		^slot3 <w>
		^slot4 nil)
	(<g> ^Gtask <gtask> -
		^Gtask |greater-algae|
		^clear-rt |enter|)
	#(write |# Starting step 3 in procedure B| (crlf))
}

# (ins :condition (WMatt = greater-algae) :action ((enter WMvalue) -> AC marine -> WMatt mineral-div-marine -> Gtask) :description "Starting step 4 in procedure B")
sp {propose*elio*procedure-b*step-4
	(state <s> 	^G.Gtask procedure-b
				^WM.slot1 greater-algae)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-b-step-4)
}
sp {apply*elio*procedure-b*step-4
	(state <s> ^operator.name elio-procedure-b-step-4
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |marine|)
	(<g> ^Gtask <gtask> -
		^Gtask |mineral-div-marine|
		^clear-rt |enter|)
	#(write |# Starting step 4 in procedure B| (crlf))
}

# (ins :condition (WMatt = mineral-div-marine) :action ((enter WMvalue) -> AC index1 -> WMatt part-mult-index1 -> Gtask) :description "Starting step 5 in procedure B")
sp {propose*elio*procedure-b*step-5
	(state <s> 	^G.Gtask procedure-b
				^WM.slot1 mineral-div-marine)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-b-step-5)
}
sp {apply*elio*procedure-b*step-5
	(state <s> ^operator.name elio-procedure-b-step-5
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |index1|)
	(<g> ^Gtask <gtask> -
		^Gtask |part-mult-index1|
		^clear-rt |enter|)
	#(write |# Starting step 5 in procedure B| (crlf))
}

# (ins :condition (WMatt = part-mult-index1) :action ((enter WMvalue) -> AC index2 -> WMatt index1-plus-index2 -> Gtask) :description "Starting step 6 in procedure B")
sp {propose*elio*procedure-b*step-6
	(state <s> 	^G.Gtask procedure-b
				^WM.slot1 part-mult-index1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-b-step-6)
}
sp {apply*elio*procedure-b*step-6
	(state <s> ^operator.name elio-procedure-b-step-6
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |index2|)
	(<g> ^Gtask <gtask> -
		^Gtask |index1-plus-index2|
		^clear-rt |enter|)
	#(write |# Starting step 6 in procedure B| (crlf))
}

# (ins :condition (WMatt = index1-plus-index2) :action ((enter WMvalue) -> AC finish -> Gtask) :description "Entering last result and finishing procedure B")
sp {propose*elio*procedure-b*step-7
	(state <s> 	^G.Gtask procedure-b
				^WM.slot1 index1-plus-index2)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-b-step-7)
}
sp {apply*elio*procedure-b*step-7
	(state <s> ^operator.name elio-procedure-b-step-7
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<g> ^Gtask <gtask> -
		^Gtask |finish|
		^clear-rt |enter|)
	#(write |# Entering last result and finishing procedure B| (crlf))
}


##### TRIPLE-LIME #####  
## (add-instr triple-lime :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (Vlabel = nil) :action ( (read limemin) -> AC ))
sp {propose*elio*triple-lime*start
	(state <s> 	^G.Gtask triple-lime
				-^V.Vlabel)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-triple-lime-start)
}
sp {apply*elio*triple-lime*start
	(state <s> ^operator.name elio-triple-lime-start
				^AC <a>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |limemin|)
	#(write |# Entering triple-lime| (crlf))
}

# (ins :condition (RT1 = nil Vlabel = limemin ) :action ((mult Vvalue 3) -> RT))
sp {propose*elio*triple-lime*mult
	(state <s> 	^G.Gtask triple-lime
				^RT.slot1 nil #-^RT.slot1
				^V.Vlabel limemin)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-triple-lime-mult)
}
sp {apply*elio*triple-lime*mult
	(state <s> ^operator.name elio-triple-lime-mult
				^Q <q>
				^V <v>)
	(<v> ^Vvalue <vvalue>)
-->
	(<q> ^slot1 |mult|
		^slot2 <vvalue>
		^slot3 3)
	#(write |# Triple-lime: mult by 3| (crlf))
}

# (ins :condition (RTans <> nil Vlabel = limemin) :action (RTans -> WMvalue (read algae) -> AC))
sp {propose*elio*triple-lime*read
	(state <s> 	^G.Gtask triple-lime
				^RT.slot4 <> nil
				^V.Vlabel limemin)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-triple-lime-read)
}
sp {apply*elio*triple-lime*read
	(state <s> ^operator.name elio-triple-lime-read
				^RT <r>
				^WM <w>
				^G <g>
				^AC <a>)
	(<w> ^slot2 <wmvalue>)
	(<r> ^slot4 <rtans>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |algae|)
	(<g> ^clear-rt |read|)
	#(write |# Triple-lime: read algae| (crlf))
}

# (ins :condition (RT1 = nil Vlabel = algae ) :action ((add WMvalue Vvalue) -> RT))
sp {propose*elio*triple-lime*add
	(state <s> 	^G.Gtask triple-lime
				^RT.slot1 nil #-^RT.slot1
				^V.Vlabel algae)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-triple-lime-add)
}
sp {apply*elio*triple-lime*add
	(state <s> ^operator.name elio-triple-lime-add
				^Q <q>
				^WM <w>
				^V <v>)
	(<w> ^slot2 <wmvalue>)
	(<v> ^Vvalue <vvalue>)
-->
	(<q> ^slot1 |add|
		^slot2 <wmvalue>
		^slot3 <vvalue>)
	#(write |# Triple-lime: add| (crlf))
}

# (ins :condition (RTtype = add ) :action (triple-lime -> WMatt RTans -> WMvalue Gparent -> Gtask)))
sp {propose*elio*triple-lime*finish
	(state <s> 	^G.Gtask triple-lime
				^RT.slot1 add)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-triple-lime-finish)
}
sp {apply*elio*triple-lime*finish
	(state <s> ^operator.name elio-triple-lime-finish
				^RT <r>
				^WM <w>
				^G <g>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<r> ^slot4 <rtans>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
-->
	(<w> ^slot1 <wmatt> -
		^slot1 |triple-lime|
		^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Triple-lime: finish| (crlf))
}


##### LESSER-EVIL #####  
## (add-instr lesser-evil :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (Vlabel = nil) :action ((read solid) -> AC))
sp {propose*elio*lesser-evil*read-solid
	(state <s> 	^G.Gtask lesser-evil
				-^V.Vlabel)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-read-solid)
}
sp {apply*elio*lesser-evil*read-solid
	(state <s> ^operator.name elio-lesser-evil-read-solid
				^AC <a>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |solid|)
	#(write |# Begin Lesser-evil: read solid| (crlf))
}

# (ins :condition (Vlabel = solid) :action (Vvalue -> WMvalue (read lime1) -> AC))
sp {propose*elio*lesser-evil*read-lime1
	(state <s> 	^G.Gtask lesser-evil
				^V.Vlabel solid)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-read-lime1)
}
sp {apply*elio*lesser-evil*read-lime1
	(state <s> ^operator.name elio-lesser-evil-read-lime1
				^V.Vvalue <vvalue>
				^WM <w>
				^AC <a>)
	(<w> ^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <vvalue>)
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |lime1|)
	#(write |# Lesser-evil: read lime1| (crlf))
}

# (ins :condition (RT1 = nil Vlabel = lime1) :action ((add WMvalue Vvalue) -> RT))
sp {propose*elio*lesser-evil*add-lime1
	(state <s> 	^G.Gtask lesser-evil
				^RT.slot1 nil #-^RT.slot1
				^V.Vlabel lime1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-add-lime1)
}
sp {apply*elio*lesser-evil*add-lime1
	(state <s> ^operator.name elio-lesser-evil-add-lime1
				^V <v>
				^WM <w>
				^Q <q>)
	(<v> ^Vvalue <vvalue>)
	(<w> ^slot2 <wmvalue>)
-->
	(<q> ^slot1 |add|
		^slot2 <wmvalue>
		^slot3 <vvalue>)
	#(write |# Lesser-evil: add lime1| (crlf))
}

# (ins :condition (RTtype = add Vlabel = lime1) :action (RTans -> WMvalue intermediate -> WMatt (? ? WMid) -> newWM  (read algae) -> AC)) ;; We can only remember one intermediate result, so the second needs to go to DM
sp {propose*elio*lesser-evil*read-algae
	(state <s> 	^G.Gtask lesser-evil
				^RT.slot1 add
				^V.Vlabel lime1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-read-algae)
}
sp {apply*elio*lesser-evil*read-algae
	(state <s> ^operator.name elio-lesser-evil-read-algae
				^WM <w>
				^NW <n>
				^RT <r>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<a> -^ACout2 |algae|)			# Don't apply twice!!
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<r> ^slot4 <rtans>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<w> ^slot1 <wmatt> -
		^slot2 <wmvalue> -
		^slot1 |intermediate|
		^slot2 <rtans>)
	(<n> ^slot1 nil
		^slot2 nil
		^slot3 <w>
		^slot4 nil)
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |algae|)
	#(write |# Lesser-evil: read-algae| (crlf))
}

# (ins :condition (Vlabel = algae) :action (Vvalue -> WMvalue (read toxin3) -> AC))
sp {propose*elio*lesser-evil*read-toxin3
	(state <s> 	^G.Gtask lesser-evil
				^V.Vlabel algae)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-read-toxin3)
}
sp {apply*elio*lesser-evil*read-toxin3
	(state <s> ^operator.name elio-lesser-evil-read-toxin3
				^V <v>
				^WM <w>
				^AC <a>)
	(<v> ^Vvalue <vvalue>)
	(<w> ^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <vvalue>)
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |toxin3|)
	#(write |# Lesser-evil: read toxin3| (crlf))
}

### I don't think this one is ever used ###
# (ins :condition (RT1 = nil Vlabel = toxin3) :action ((add WMvalue Vvalue) -> RT))
sp {propose*elio*lesser-evil*add-toxin3
	(state <s> 	^G.Gtask lesser-evil
				^RT.slot1 nil #-^RT.slot1
				^V.Vlabel toxin3)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-add-toxin3)
}
sp {apply*elio*lesser-evil*add-toxin3
	(state <s> ^operator.name elio-lesser-evil-add-toxin3
				^Q <q>
				^WM <w>
				^V <v>)
	(<v> ^Vvalue <vvalue>)
	(<w> ^slot2 <wmvalue>)
-->
	(<q> ^slot1 |add|
		^slot2 <wmvalue>
		^slot3 <vvalue>)
	#(write |# Lesser-evil: read toxin3| (crlf))
}

# (ins :condition (RTtype = add Vlabel = toxin3) :action  (RTans -> WMvalue WMprev -> RTid))
sp {propose*elio*lesser-evil*toxin3
	(state <s> 	^G.Gtask lesser-evil
				^RT.slot1 add
				^V.Vlabel toxin3)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-toxin3)
}
# NOTE: Might not work if WMprev == nil
sp {apply*elio*lesser-evil*toxin3
	(state <s> ^operator.name elio-lesser-evil-toxin3
				^RT <r>
				^Q <q>
				^WM <w>
				^V <v>)
	(<v> ^Vvalue <vvalue>)
	(<w> ^slot2 <wmvalue>
		^slot3 <wmprev>)
	(<wmprev> ^slot1 <pvatt>
			^slot2 <pvvalue>
			^slot3 <pvprev>
			^slot4 <pvnext>)
	(<r> ^slot4 <rtans>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <rtans>)
	(<q> ^slot1 <pvatt>
		^slot2 <pvvalue>
		^slot3 <pvprev>
		^slot4 <pvnext>)
	#(write |# Lesser-evil: toxin3| (crlf))
}

# (ins :condition (RTatt = intermediate) :action (RTprev -> WMprev (greater-than WMvalue RTvalue) -> RT))
sp {propose*elio*lesser-evil*read-intermediate
	(state <s> 	^G.Gtask lesser-evil
				^RT.slot1 intermediate)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-read-intermediate)
}
sp {apply*elio*lesser-evil*read-intermediate
	(state <s> ^operator.name elio-lesser-evil-read-intermediate
				^RT <r>
				^Q <q>
				^G <g>
				^WM <w>)
	(<w> ^slot2 <wmvalue>
		^slot3 <wmprev>)
	(<q> -^slot1)				# So it doesn't apply twice
	(<r> #^slot1 <rttype>
		#^slot4 <r4>
		^slot2 <arg1>
		^slot3 <arg2>)
	(<arg2> ^slot4 <rpnext>)
-->
	(<w> ^slot3 <wmprev> -
		^slot3 <arg2>)
	(<arg2> ^slot4 <rpnext> -
			^slot4 <w>)
	#(<w2> ^slot1 <rttype>
	#		^slot2 <arg1>
	#		^slot3 <arg2>
	#		^slot4 <r4>)
	(<q> ^slot1 |greater-than|
		^slot2 <wmvalue>
		^slot3 <arg1>)
	(<g> ^clear-rt |greater-than|)
	#(write |# Lesser-evil: read intermediate. Rewiring: | <w> |->| <wmprev> | to | <arg2> (crlf))
}

### I don't think this is ever used ###
# (ins :condition (RTtype = greater-than RTans = true) :action (RTarg1 -> WMvalue lesser-evil -> WMatt  Gparent -> Gtask))
sp {propose*elio*lesser-evil*greater-than-true
	(state <s> 	^G.Gtask lesser-evil
				^RT <r>)
	(<r> ^slot1 greater-than
		^slot4 true)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-greater-than-true)
}
sp {apply*elio*lesser-evil*greater-than-true
	(state <s> ^operator.name elio-lesser-evil-greater-than-true
				^RT <r>
				^WM <w>
				^G <g>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<r> ^slot2 <arg1>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <arg1>
		^slot1 <wmatt> -
		^slot1 |lesser-evil|)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Lesser-evil: Greater-than true| (crlf))
}

#(ins :condition (RTtype = greater-than RTans = false) :action (RTarg2 -> WMvalue lesser-evil -> WMatt Gparent -> Gtask)))
sp {propose*elio*lesser-evil*greater-than-false
	(state <s> 	^G.Gtask lesser-evil
				^RT <r>)
	(<r> ^slot1 greater-than
		^slot4 false)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-lesser-evil-greater-than-false)
}
sp {apply*elio*lesser-evil*greater-than-false
	(state <s> ^operator.name elio-lesser-evil-greater-than-false
				^RT <r>
				^WM <w>
				^G <g>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<r> ^slot3 <arg2>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <arg2>
		^slot1 <wmatt> -
		^slot1 |lesser-evil|)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Lesser-evil: Greater-than false| (crlf))
}


##### SOLID-DIV-LIME #####  
## (add-instr solid-div-lime  :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (Vlabel = nil)  :action ((read solid) -> AC))
sp {propose*elio*solid-div-lime*read-solid
	(state <s> 	^G.Gtask solid-div-lime
				-^V.Vlabel)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-solid-div-lime-read-solid)
}
sp {apply*elio*solid-div-lime*read-solid
	(state <s> ^operator.name elio-solid-div-lime-read-solid
				^AC <a>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |solid|)
	#(write |# Solid-div-lime: read solid| (crlf))
}

# (ins :condition (Vlabel = solid) :action (Vvalue -> WMvalue (read lime1) -> AC))
sp {propose*elio*solid-div-lime*read-lime1
	(state <s> 	^G.Gtask solid-div-lime
				^V.Vlabel solid)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-solid-div-lime-read-lime1)
}
sp {apply*elio*solid-div-lime*read-lime1
	(state <s> ^operator.name elio-solid-div-lime-read-lime1
				^V <v>
				^WM <w>
				^AC <a>)
	(<v> ^Vvalue <vvalue>)
	(<w> ^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <vvalue>)
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |read|
		^ACout2 |lime1|)
	#(write |# Solid-div-lime: read lime1| (crlf))
}

# (ins :condition (RT1 = nil Vlabel = lime1) :action ((div WMvalue Vvalue) -> RT))
sp {propose*elio*solid-div-lime*div-lime1
	(state <s> 	^G.Gtask solid-div-lime
				^RT.slot1 nil #-^RT.slot1
				^V.Vlabel lime1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-solid-div-lime-div-lime1)
}
sp {apply*elio*solid-div-lime*div-lime1
	(state <s> ^operator.name elio-solid-div-lime-div-lime1
				^V <v>
				^WM <w>
				^Q <q>)
	(<v> ^Vvalue <vvalue>)
	(<w> ^slot2 <wmvalue>)
-->
	(<q> ^slot1 |div|
		^slot2 <wmvalue>
		^slot3 <vvalue>)
	#(write |# Solid-div-lime: div lime1| (crlf))
}

# (ins :condition (RTtype = div) :action (solid-div-lime -> WMatt RTans -> WMvalue Gparent -> Gtask)))
sp {propose*elio*solid-div-lime*finish
	(state <s> 	^G.Gtask solid-div-lime
				^RT.slot1 div)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-solid-div-lime-finish)
}
sp {apply*elio*solid-div-lime*finish
	(state <s> ^operator.name elio-solid-div-lime-finish
				^RT <r>
				^WM <w>
				^G <g>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<r> ^slot4 <rtans>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
-->
	(<w> ^slot2 <wmvalue> -
		^slot2 <rtans>
		^slot1 <wmatt> -
		^slot1 |solid-div-lime|)
	(<g> ^Gtask <gtask> -
		^Gtask <gparent>)
	#(write |# Solid-div-lime: finish| (crlf))
}



##### PROCEDURE-C #####  
## (add-instr procedure-c :input (Vlabel Vvalue) :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (Gtop = nil) :action (WMid -> Gtop Gtask -> Gparent triple-lime -> Gtask) :description "Starting step 1 in procedure C")
sp {propose*elio*procedure-c*start
	(state <s> 	^G <g>)
	(<g> ^Gtask procedure-c
		^Gtop nil)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-c-start)
}
sp {apply*elio*procedure-c*start
	(state <s> ^operator.name elio-procedure-c-start
				^WM <w>
				^G <g>)
	(<g> ^Gtop <gtop>
		^Gparent <gparent>
		^Gtask <gtask>)
-->
	(<g> ^Gtop <gtop> -
		^Gtop <w>
		^Gparent <gparent> -
		^Gparent <gtask>
		^Gtask <gtask> -
		^Gtask |triple-lime|)
	#(write |# Starting step 1 in procedure C| (crlf))
}

# (ins :condition (WMatt = triple-lime) :action ((enter WMvalue) -> AC particulate -> WMatt (? ? WMid) -> newWM lesser-evil -> Gtask) :description "Starting step 2 in procedure C")
sp {propose*elio*procedure-c*step-2
	(state <s> 	^G.Gtask procedure-c
				^WM.slot1 triple-lime)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-c-step-2)
}
sp {apply*elio*procedure-c*step-2
	(state <s> ^operator.name elio-procedure-c-step-2
				^WM <w>
				^NW <n>
				^AC <a>
				^G <g>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |particulate|)
	(<n> ^slot1 nil
		^slot2 nil
		^slot3 <w>
		^slot4 nil)
	(<g> ^Gtask <gtask> -
		^Gtask |lesser-evil|
		^clear-rt |enter|)
	#(write |# Starting step 2 in procedure C| (crlf))
}

# (ins :condition (WMatt = lesser-evil) :action ((enter WMvalue) -> AC mineral -> WMatt part-plus-mineral -> Gtask) :description "Starting step 3 in procedure C")
sp {propose*elio*procedure-c*step-3
	(state <s> 	^G.Gtask procedure-c
				^WM.slot1 lesser-evil)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-c-step-3)
}
sp {apply*elio*procedure-c*step-3
	(state <s> ^operator.name elio-procedure-c-step-3
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |mineral|)
	(<g> ^Gtask <gtask> -
		^Gtask |part-plus-mineral|
		^clear-rt |enter|)
	#(write |# Starting step 3 in procedure C| (crlf))
}

#(ins :condition (WMatt = part-plus-mineral) :action ((enter WMvalue) -> AC index1 -> WMatt (? ? WMid) -> newWM solid-div-lime -> Gtask) :description "Starting step 4 in procedure C")
sp {propose*elio*procedure-c*step-4
	(state <s> 	^G.Gtask procedure-c
				^WM.slot1 part-plus-mineral)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-c-step-4)
}
sp {apply*elio*procedure-c*step-4
	(state <s> ^operator.name elio-procedure-c-step-4
				^WM <w>
				^NW <n>
				^AC <a>
				^G <g>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |index1|)
	(<n> ^slot1 nil
		^slot2 nil
		^slot3 <w>
		^slot4 nil)
	(<g> ^Gtask <gtask> -
		^Gtask |solid-div-lime|
		^clear-rt |enter|)
	#(write |# Starting step 4 in procedure C| (crlf))
}

# (ins :condition (WMatt = solid-div-lime) :action ((enter WMvalue) -> AC marine -> WMatt index1-div-marine -> Gtask) :description "Starting step 5 in procedure C")
sp {propose*elio*procedure-c*step-5
	(state <s> 	^G.Gtask procedure-c
				^WM.slot1 solid-div-lime)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-c-step-5)
}
sp {apply*elio*procedure-c*step-5
	(state <s> ^operator.name elio-procedure-c-step-5
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |marine|)
	(<g> ^Gtask <gtask> -
		^Gtask |index1-div-marine|
		^clear-rt |enter|)
	#(write |# Starting step 5 in procedure C| (crlf))
}

# (ins :condition (WMatt = index1-div-marine) :action ((enter WMvalue) -> AC index2 -> WMatt index2-min-mineral -> Gtask) :description "Starting step 6 in procedure C")
sp {propose*elio*procedure-c*step-6
	(state <s> 	^G.Gtask procedure-c
				^WM.slot1 index1-div-marine)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-c-step-6)
}
sp {apply*elio*procedure-c*step-6
	(state <s> ^operator.name elio-procedure-c-step-6
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |index2|)
	(<g> ^Gtask <gtask> -
		^Gtask |index2-min-mineral|
		^clear-rt |enter|)
	#(write |# Starting step 6 in procedure C| (crlf))
}

# (ins :condition (WMatt = index2-min-mineral) :action ((enter WMvalue) -> AC finish -> Gtask) :description "Entering last result and finishing procedure C")
sp {propose*elio*procedure-c*step-7
	(state <s> 	^G.Gtask procedure-c
				^WM.slot1 index2-min-mineral)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-c-step-7)
}
sp {apply*elio*procedure-c*step-7
	(state <s> ^operator.name elio-procedure-c-step-7
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<g> ^Gtask <gtask> -
		^Gtask |finish|
		^clear-rt |enter|)
	#(write |# Entering last result and finishing procedure C| (crlf))
}



##### PROCEDURE-D #####  
## (add-instr procedure-d :input (Vlabel Vvalue) :input (Vlabel Vvalue) :variables (WMatt WMvalue WMprev) :declarative ((RTtype RTarg1 RTarg2 RTans)(RTatt RTvalue RTprev))

# (ins :condition (Gtop = nil) :action (WMid -> Gtop Gtask -> Gparent triple-lime -> Gtask) :description "Starting step 1 in procedure D")
sp {propose*elio*procedure-d*start
	(state <s> 	^G <g>)
	(<g> ^Gtask procedure-d
		^Gtop nil)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-d-start)
}
sp {apply*elio*procedure-d*start
	(state <s> ^operator.name elio-procedure-d-start
				^WM <w>
				^G <g>)
	(<g> ^Gtop <gtop>
		^Gparent <gparent>
		^Gtask <gtask>)
-->
	(<g> ^Gtop <gtop> -
		^Gtop <w>
		^Gparent <gparent> -
		^Gparent <gtask>
		^Gtask <gtask> -
		^Gtask |triple-lime|)
	#(write |# Starting step 1 in procedure D| (crlf))
}

# (ins :condition (WMatt = triple-lime) :action ((enter WMvalue) -> AC particulate -> WMatt (? ? WMid) -> newWM lesser-evil -> Gtask) :description "Starting step 2 in procedure D")
sp {propose*elio*procedure-d*step-2
	(state <s> 	^G.Gtask procedure-d
				^WM.slot1 triple-lime)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-d-step-2)
}
sp {apply*elio*procedure-d*step-2
	(state <s> ^operator.name elio-procedure-d-step-2
				^WM <w>
				^NW <n>
				^AC <a>
				^G <g>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |particulate|)
	(<n> ^slot1 nil
		^slot2 nil
		^slot3 <w>
		^slot4 nil)
	(<g> ^Gtask <gtask> -
		^Gtask |lesser-evil|
		^clear-rt |enter|)
	#(write |# Starting step 2 in procedure D| (crlf))
}

# (ins :condition (WMatt = lesser-evil) :action ((enter WMvalue) -> AC mineral -> WMatt (? ? WMid) -> newWM solid-div-lime -> Gtask) :description "Starting step 3 in procedure D")
sp {propose*elio*procedure-d*step-3
	(state <s> 	^G.Gtask procedure-d
				^WM.slot1 lesser-evil)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-d-step-3)
}
sp {apply*elio*procedure-d*step-3
	(state <s> ^operator.name elio-procedure-d-step-3
				^WM <w>
				^NW <n>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>
		^slot4 <wmnext>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |mineral|)
	(<n> ^slot1 nil
		^slot2 nil
		^slot3 <w>
		^slot4 nil)
	(<g> ^Gtask <gtask> -
		^Gtask |solid-div-lime|
		^clear-rt |enter|)
	#(write |# Starting step 3 in procedure D| (crlf))
}

# (ins :condition (WMatt = solid-div-lime) :action ((enter WMvalue) -> AC marine -> WMatt mineral-div-marine -> Gtask) :description "Starting step 4 in procedure D")
sp {propose*elio*procedure-d*step-4
	(state <s> 	^G.Gtask procedure-d
				^WM.slot1 solid-div-lime)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-d-step-4)
}
sp {apply*elio*procedure-d*step-4
	(state <s> ^operator.name elio-procedure-d-step-4
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gparent <gparent>
		^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |marine|)
	(<g> ^Gtask <gtask> -
		^Gtask |mineral-div-marine|
		^clear-rt |enter|)
	#(write |# Starting step 4 in procedure D| (crlf))
}

# (ins :condition (WMatt = mineral-div-marine) :action ((enter WMvalue) -> AC index1 -> WMatt part-mult-index1 -> Gtask) :description "Starting step 5 in procedure D")
sp {propose*elio*procedure-d*step-5
	(state <s> 	^G.Gtask procedure-d
				^WM.slot1 mineral-div-marine)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-d-step-5)
}
sp {apply*elio*procedure-d*step-5
	(state <s> ^operator.name elio-procedure-d-step-5
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |index1|)
	(<g> ^Gtask <gtask> -
		^Gtask |part-mult-index1|
		^clear-rt |enter|)
	#(write |# Starting step 5 in procedure D| (crlf))
}

# (ins :condition (WMatt = part-mult-index1) :action ((enter WMvalue) -> AC index2 -> WMatt index1-plus-index2 -> Gtask) :description "Starting step 6 in procedure D")
sp {propose*elio*procedure-d*step-6
	(state <s> 	^G.Gtask procedure-d
				^WM.slot1 part-mult-index1)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-d-step-6)
}
sp {apply*elio*procedure-d*step-6
	(state <s> ^operator.name elio-procedure-d-step-6
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot1 <wmatt>
		^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<w> ^slot1 <wmatt> -
		^slot1 |index2|)
	(<g> ^Gtask <gtask> -
		^Gtask |index1-plus-index2|
		^clear-rt |enter|)
	#(write |# Starting step 6 in procedure D| (crlf))
}

# (ins :condition (WMatt = index1-plus-index2) :action ((enter WMvalue) -> AC finish -> Gtask) :description "Entering last result and finishing procedure D")
sp {propose*elio*procedure-d*step-7
	(state <s> 	^G.Gtask procedure-d
				^WM.slot1 index1-plus-index2)
-->
	(<s> ^operator <o> +)
	(<o> ^name elio-procedure-d-step-7)
}
sp {apply*elio*procedure-d*step-7
	(state <s> ^operator.name elio-procedure-d-step-7
				^WM <w>
				^AC <a>
				^G <g>)
	(<g> ^Gtask <gtask>)
	(<w> ^slot2 <wmvalue>)
	(<a> ^ACout1 <a1>
		^ACout2 <a2>)
-->
	(<a> ^ACout1 <a1> -
		^ACout2 <a2> -
		^ACout1 |enter|
		^ACout2 <wmvalue>)
	(<g> ^Gtask <gtask> -
		^Gtask |finish|
		^clear-rt |enter|)
	#(write |# Entering last result and finishing procedure D| (crlf))
}

