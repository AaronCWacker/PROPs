#####	Author: Bryan Stearns, December 2016
# Interface an Actransfer-buffer-simulating working memory with SMEM.
# Working memory has:
# <s> 	^RT		# Receptacle for results
#		^Q		# Query commands
#			^slot1
#			^slot2
#			^slot...
#####

smem --set learning on

chunk singleton state G identifier
chunk singleton state V identifier
chunk singleton state WM identifier
chunk singleton identifier slot3 identifier
chunk singleton identifier slot4 identifier
chunk singleton state NW identifier
chunk singleton state RT identifier
chunk singleton state Q identifier
chunk singleton state AC identifier


# Buffer Init #
sp {propose*elio*init
	(state <s> ^superstate nil
				-^WM)
-->
	(<s> ^operator <o> + >)
	(<o> ^name buffer-init)
}
sp {apply*elio*init
	(state <s> ^operator.name buffer-init
				^smem.command <scmd>
				^io.output-link <ol>)
-->
	(<s> 	^G <g>		# control
			^V <v>		# input
			^WM <w>		# variables
			^NW <n>		# newWM
			^RT <r>		# retrieval
			^Q <q>		# retrieval queries
			^AC <a>)	# actions
	(<g> ^Gcontrol nil
		 ^Gtop nil
		 ^Gparent nil)
	(<w> ^slot1 nil
		 ^slot2 nil
		 ^slot3 nil
		 ^slot4 nil)
	(<a> ^props-agnostic-add true)	# Learned actions which add to AC don't test for existing values
	(<scmd> ^query <qq>)	# This agent code only causes queries, so have static query structure
	(write (crlf) INITTED (crlf))
	# Query and Action don't need to be given empty values
}

# FINISH #
# Custom for Soar - don't include as a PROP instruction set #
sp {lib*actr*propose*finish
	(state <s> ^G.Gtask finish)
-->
	(<s> ^operator <o> +)
	(<o> ^name actransfer-finish)
}
sp {lib*actr*apply*finish
	(state <s> ^operator.name actransfer-finish
				^G <g>
				^WM <w>
				^AC <a>
				^RT <r>)
	(<g> ^Gcontrol <gcontrol>
		^Gtask finish
		^Gtop <gtop>
		^Gparent <gparent>)
	(<w> ^slot1 <w1>
		^slot2 <w2>
		^slot3 <w3>
		^slot4 <w4>)
	(<r> ^slot1 <r1>
		^slot2 <r2>
		^slot3 <r3>)
-->
	# Reset Goal
	(<g> ^Gcontrol <gcontrol> -
		^Gtask finish -
		^Gtop <gtop> -
		^Gparent <gparent> -
		^Gcontrol nil
		#^Gtask nil
		^Gtop nil
		^Gparent nil)
	# Reset WM
	(<w> ^slot1 <w1> -
		^slot2 <w2> -
		^slot3 <w3> -
		^slot4 <w4> -
		^slot1 nil
		^slot2 nil
		^slot3 nil
		^slot4 nil)
	# Prompt to reset manual sequence
	(<s> ^props-flag reset-manual-sequence)
	(write (crlf) (crlf) |*** TASK FINISHED ***| (crlf) )
}
sp {lib*actr*apply*finish*remove-actions
	(state <s> ^operator.name actransfer-finish
				^AC (<ac> ^action <a>))
-->
	(<ac> ^action <a> -)
}

sp {lib*actr*elaborate*finish
	(state <s> ^G.Gtask finish
				^io.output-link <ol>)
-->
	# Proclaim finitude
	(<ol> ^finish <f>)
	(<f> ^finish true)
	#(halt)
}

#### SWITCH TO SECONDARY BEHAVIOR IN CASE OF LACK OF PROPS INSTRUCTIONS ####
# (IN THIS CASE, HALTING)
sp {lib*actr*instruction*search*impasse
	(state <s>	^WM 
				^props-flag impasse)
-->
	(write |    Well, well, well. I see I've run out of instructions. Goodnight.| (crlf) )
	(halt)
}


#### TASK-SPECIFIC: TRANSFER INPUT TO VISUAL ####
sp {lib*actr*elaborate*visual*in
	(state <s> ^V <v>
				^io.input-link <il>)
	(<il> ^in1 <i1>
		^in2 <i2>)
-->
	(<v> ^Vlabel <i1>
		^Vvalue <i2>)
	(write (crlf) |Read: "| <i1> |" "| <i2> |"|)
}



# TRANSFER INPUT TO TASK SPECIFICATION
sp {lib*actr*elaborate*input*task
	(state <s> ^io.input-link <il>
			   ^G <g>)
	(<il> ^task <task>)
	(<g> -^Gtask finish)
-->
	(<g> ^Gtask <task>)
	(write (crlf) |*** TASK SET TO | <task> | ***| )
}

sp {lib*actr*elaborate*action*output
	(state <s> ^AC.action <a>
				^io.output-link <ol>)
	(<a> ^out1 <o1> )
-->
	(<ol> ^say <a>)
	(write (crlf) |Say: | <o1> (crlf) )
}


sp {lib*actr*set*clean*output
	:o-support
	(state <s> ^io.output-link <ol>
				^AC <a>)
	(<ol> ^say <os>)
	(<a> ^action <os>)
	(<os> ^status complete)
-->
	(<a> ^action <os> -)
}



# TRANSFER QUERIES TO SMEM
sp {lib*actr*elaborate*query*transfer
	(state <s> ^RT <r>
				^smem.command.query <q>)
	(<r> ^<attr> {<val> <> nil <> error <> success})
-->
	(<q> ^<attr> <val>)
}

# TRANSFER QUERY RESULTS FROM SMEM
sp {lib*actr*elaborate*query*collect
	(state <s> ^smem.result.retrieved <sret>
				^RT <r>)
	(<sret> ^{<slot> <> |isa|} <val>)
-->
	(<r> ^<slot> <val> )
}
sp {lib*actr*elaborate*query*collect*replace		#FIXME: removing an i-supported nil
	:o-support
	(state <s> ^smem.result.retrieved <sret>
				^RT <r>)
	(<sret> ^<slot> {<val> <> nil})
	(<r> ^<slot> {<old> << nil error >>})
-->
	(<r> ^<slot> <old> -)
}
sp {lib*actr*elaborate*query*nil
	(state <s> ^smem.result <sres>
			^RT <r>)
	(<sres> -^success
			-^failure)
-->
	(<r> ^result nil
		^slot1 nil
		^slot2 nil
		^slot3 nil)
}
sp {lib*actr*elaborate*query*success
	(state <s> ^smem <smem>
			^RT <r>)
	(<smem> ^result.success
			^command.query.<any>)
-->
	(<r> ^result success)
}
sp {lib*actr*elaborate*query*failure*error
	(state <s> ^smem <smem>
			^RT <r>)
	(<smem> ^result.failure
			^command.query.<any>)
-->
	(<r> ^result error)
}

sp {lib*actr*elaborate*query*failure*nil
	(state <s> ^smem <smem>
			^RT <r>)
	(<smem> ^result.failure
			^command.query <cq>)
	(<cq> -^<any> )
-->
	(<r> ^result nil
		^slot1 nil
		^slot2 nil
		^slot3 nil)
}

# FORWARD QUERIES TO RT
sp {lib*actr*set*queries*rt
	:o-support
	(state <s> ^Q <q>
				^RT <r>)
	(<q> ^<slot> <val>)
	(<r> ^<slot> {<old> <> <val>})
-->
	(<r> ^<slot> <old> -
		^<slot> <val>)
	(<q> ^<slot> <val> -)
}
sp {lib*actr*set*queries*rt*remove-q
	:o-support
	(state <s> ^Q <q>
				^RT <r>)
	(<q> ^<slot> <val>)
	(<r> ^<slot> <val>)
-->
	(<q> ^<slot> <val> -)
}

# CLEAN RETRIEVAL BUFFER COMMAND AFTER GETTING RESULT
sp {lib*actr*apply*query*collect*clean					# FIXME: Replacing with o-supported nil
	:o-support
	(state <s> #^operator
			^G <g>
			-^Q.<slot> 
			^RT <r>)
	(<r> ^<slot> {<val> <> nil})
	(<g> ^clear-rt <any>)
-->
	(<r> ^<slot> <val> -)
	(<g> ^clear-rt <any> -)
}
sp {lib*actr*apply*query*collect*clean*nonil
	:o-support
	(state <s> ^G <g>
			^Q.<slot> <> <val>
			^RT <r>)
	(<r> ^<slot> {<val> <> nil})
	(<g> ^clear-rt <any>)
-->
	(<r> ^<slot> <val> -)
	(<g> ^clear-rt <any> -)
}
sp {lib*actr*apply*query*collect*clean*nonil*all
	:o-support
	(state <s> ^G <g>
			^Q <q>
			^RT <r>)
	-{(<r> ^<slot> <rval>)
	  (<q> ^<slot> <> <rval>)}
	(<g> ^clear-rt <any>)
-->
	(<g> ^clear-rt <any> -)
	#(write (crlf) |CLEAN Q!| (crlf))
}
# Technically there should be the case where ^clear-rt and all RT == Q, but that won't happen

# NEWWM #
sp {lib*actr*set*newwm*swap
	:o-support
	(state <s> ^NW <n>
				^WM <w>)
	(<n> ^slot1 <n1>
		^slot2 <n2>
		^slot3 {<n3> <> <w>}
		^slot4 <n4>)
-->
	(<s> ^WM <w> -
		^WM <w2>)
	(<w2> ^slot1 <n1>
		^slot2 <n2>
		^slot3 <n3>
		^slot4 <n4>)
	(<n> ^slot1 <n1> -
		^slot2 <n2> -
		^slot3 <n3> -
		^slot4 <n4> -)
}
sp {lib*actr*set*newwm*swap*with-next			# This is just for propose*elio*part-plus-mineral*finish
	:o-support
	(state <s> ^NW <n>
				^WM <w>)
	(<n> ^slot1 <n1>
		^slot2 <n2>
		^slot3 <w>
		^slot4 <n4>)
	(<w> ^slot4 <wmnext>)
-->
	(<s> ^WM <w> -
		^WM <w2>)
	(<w2> ^slot1 <n1>
		^slot2 <n2>
		^slot3 <w>
		^slot4 <n4>)
	(<w> ^slot4 <wmnext> -
		^slot4 <w2>)
	(<n> ^slot1 <n1> -
		^slot2 <n2> -
		^slot3 <w> -
		^slot4 <n4> -)
}
