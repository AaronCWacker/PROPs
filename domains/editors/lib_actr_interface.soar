#####	Author: Bryan Stearns, December 2016
# Interface an ACT-R-buffer-simulating working memory with SMEM.
# Working memory has:
# <s> 	^RT		# Receptacle for results
#		^Q		# Query commands
#			^slot1
#			^slot2
#			^slot...
# Any successful queries fill 
#####

smem --set learning on

chunk singleton state G identifier
chunk singleton state V identifier
chunk singleton state WM identifier
chunk singleton identifier slot3 identifier
chunk singleton identifier slot4 identifier
chunk singleton state NW identifier
chunk singleton state RT identifier
chunk singleton state Q identifier
chunk singleton state AC identifier

#sp {elio*hack*prefer*greater-algae*div-2
#	(state <s> ^operator <o1> +
#				^operator <o2> +)
#	(<o1> ^name elio-greater-algae-div-2)
#	(<o2> ^name elio-greater-algae-read-solid)
#-->
#	(<s> ^operator <o1> > <o2>)
#}

# Buffer Init #
sp {propose*elio*init
	(state <s> ^superstate nil
				-^WM)
-->
	(<s> ^operator <o> + >)
	(<o> ^name buffer-init)
}
sp {apply*elio*init
	(state <s> ^operator.name buffer-init
				^smem.command <scmd>
				^io.output-link <ol>)
-->
	(<s> 	^G <g>		# control
			^V <v>		# input
			^WM <w>		# variables
			^NW <n>		# newWM
			^RT <r>		# retrieval
			^Q <q>		# retrieval queries
			^AC <a>)	# actions
	(<g> #^Gtask nil
		^Gcontrol nil
		^Gtop nil
		#^il-task nil	# cache of Gtask commanded on input-link
		^Gparent nil)
	(<w> ^slot1 nil
		^slot2 nil
		^slot3 nil
		^slot4 nil)
	(<a> ^props-agnostic-add true)	# Learned actions which add to AC don't test for existing values
	#(<a> ^ACout1 nil
	#	^ACout2 nil
	#	^ACout3 nil)
	#(<r> ^slot1 nil
	#	^slot2 nil
	#	^slot3 nil)
		#^slot4 nil)		# Slot4 is the answer slot, only existing when there is a result
	(<scmd> ^query <qq>)	# This agent code only causes queries, so have static query structure
	(write (crlf) INITTED (crlf))
	# Query and Action don't need to be given empty values
}

# FINISH #
# Custom for Soar - don't include as a PROP instruction set ##
sp {lib*actr*propose*finish
	(state <s> ^G.Gtask finish)
-->
	(<s> ^operator <o> +)
	(<o> ^name actransfer-finish)
}
sp {lib*actr*apply*finish
	(state <s> ^operator.name actransfer-finish
				^G <g>
				^WM <w>
				^AC <a>
				^RT <r>)
	(<g> ^Gcontrol <gcontrol>
		^Gtask finish
		^Gtop <gtop>
		#^il-task <iltask>
		^Gparent <gparent>)
	(<w> ^slot1 <w1>
		^slot2 <w2>
		^slot3 <w3>
		^slot4 <w4>)
	#(<a> ^ACout1 <a1>
	#	^ACout2 <a2>
	#	^ACout3 <a3>)
	(<r> ^slot1 <r1>
		^slot2 <r2>
		^slot3 <r3>)
-->
	# Reset Goal
	(<g> ^Gcontrol <gcontrol> -
		^Gtask finish -
		^Gtop <gtop> -
		#^il-task <iltask> -
		^Gparent <gparent> -
		^Gcontrol nil
		#^Gtask nil
		^Gtop nil
		#^il-task nil
		^Gparent nil)
	# Reset WM
	(<w> ^slot1 <w1> -
		^slot2 <w2> -
		^slot3 <w3> -
		^slot4 <w4> -
		^slot1 nil
		^slot2 nil
		^slot3 nil
		^slot4 nil)
	# Reset AC
	#(<a> ^ACout1 <a1> -
	#	^ACout2 <a2> -
	#	^ACout3 <a3> -
	#	^ACout1 nil
	#	^ACout2 nil
	#	^ACout3 nil)
	# Reset RT
	#(<r> ^slot1 <r1> -
	#	^slot2 <r2> -
	#	^slot3 <r3> -)
	# Prompt to reset manual sequence
	(<s> ^props-flag reset-manual-sequence)
	(write (crlf) (crlf) |*** TASK FINISHED ***| (crlf) )
}
sp {lib*actr*apply*finish*remove-actions
	(state <s> ^operator.name actransfer-finish
				^AC (<ac> ^action <a>))
-->
	(<ac> ^action <a> -)
}

sp {lib*actr*elaborate*finish
	(state <s> ^G.Gtask finish
				^io.output-link <ol>)
-->
	# Proclaim finitude
	(<ol> ^finish <f>)
	(<f> ^finish true)
	#(halt)
}

#### SWITCH TO SECONDARY BEHAVIOR IN CASE OF LACK OF PROPS INSTRUCTIONS ####
# (IN THIS CASE, HALTING)
sp {lib*actr*instruction*search*impasse
	(state <s>	^WM 
				^props-flag impasse)
-->
	(write |    Well, well, well. I see I've run out of instructions. Goodnight.| (crlf) )
	(halt)
}

# TRANSFER INPUT TO TASK SPECIFICATION
sp {lib*actr*elaborate*input*task
	(state <s> ^io.input-link <il>
			   ^G <g>)
	(<il> ^task <task>)
	(<g> -^Gtask finish)
-->
	(<g> ^Gtask <task>)
	(write (crlf) |*** TASK SET TO | <task> | ***| )
}

# TRANSFER ACTION TO OUTPUT
#sp {lib*actr*set*nil*output*1
#	(state <s> ^operator
#				^AC <a>)
#	(<a> -^ACout1)
#-->
#	(<a> ^ACout1 nil)
#}
#sp {lib*actr*set*nil*output*2
#	(state <s> ^operator
#				^AC <a>)
#	(<a> -^ACout2)
#-->
#	(<a> ^ACout2 nil)
#}
#sp {lib*actr*set*nil*output*3
#	(state <s>  ^operator
#				^AC <a>)
#	(<a> -^ACout3)
#-->
#	(<a> ^ACout3 nil)
#}
sp {lib*actr*elaborate*action*output
	(state <s> ^AC.action <a>
				^io.output-link <ol>)
	(<a> ^out1 <o1> )
	#(<ol> -^say.status complete)
-->
	(<ol> ^say <a>)
	#(<a> ^out1 <o1>)
	#(<a> ^ACout1 <o1> -)  # Sometimes this line doesn't take effect for some reason. (And it's not added the same loop elsewhere.)
	#(<a> ^ACout1 nil)
	(write (crlf) |Say: | <o1> (crlf) )
}
#sp {lib*actr*elaborate*action*output2
#	(state <s> ^AC <a>
#				^io.output-link <ol>)
#	(<a> ^ACout2 {<o2> <> nil})
#	(<ol> ^say <p>)
#-->
#	(<p> ^out2 <o2>)
#	#(<a> ^ACout2 <o2> -)
#	#(<a> ^ACout2 nil)
#	(write (crlf) |Say2: | <o2> )
#}
#sp {lib*actr*elaborate*action*output3
#	(state <s> ^AC <a>
#				^io.output-link <ol>)
#	(<a> ^ACout3 {<o3> <> nil})
#	(<ol> ^say <p>)
#-->
#	(<p> ^out3 <o3>)
#	#(<a> ^ACout3 <o3> -)
#	#(<a> ^ACout3 nil)
#	(write (crlf) |Say3: | <o3> )
#}

# ONLY CLEAN "ENTER" COMMANDS - OTHERS CAN STAY; DUPLICATE ENTER COMMANDS NEED TO BE UNIQUE THOUGH
# (Other commands might not have out2 & out3)
#sp {lib*actr*set*clean*output
#	:o-support
#	(state <s> ^io.output-link <ol>
#				^AC <a>)
#	(<ol> ^say <os>)
#	(<os> ^out1 |next-instruction|
#		^out2 <os2>
#		^out3 <os3>
#		^status complete)
#	(<a> ^ACout1 |next-instruction|
#		^ACout2 <os2>
#		^ACout3 <os3>)
#-->
#	(<ol> ^say <os> -)
#	(<a> ^ACout1 |next-instruction| -
#		^ACout2 <os2> -
#		^ACout2 <os3> -)
#	#(write (crlf) |Clean: next-instruction | <os2>)
#}
# Failsafe clean, for when AC cleaning above doesn't take effect for some reason
#sp {lib*actr*set*clean*ACouts*failsafe
#	:o-support
#	(state <s> ^AC <a>)
#	(<a> ^{<attr> << ACout1 ACout2 ACout3 >>} {<o1> <> nil}
#         ^<attr> nil)
#-->
#	(<a> ^<attr> <o1> -) 
#}

sp {lib*actr*set*clean*output1
	:o-support
	(state <s> ^io.output-link <ol>
				^AC <a>)
	(<ol> ^say <os>)
	(<a> ^action <os>)
	(<os> ^status complete)
-->
	#(<ol> ^say <os> -)
	(<a> ^action <os> -)
	#(write (crlf) |Clean: | <os1>)
}
#sp {lib*actr*set*clean*output2
#	:o-support
#	(state <s> ^io.output-link <ol>
#				^AC <a>)
#	(<ol> ^say <os>)
#	(<os> ^out2 <os2>
#		^status complete)
#	(<a> ^ACout2 <os2>)
#-->
#	(<a> ^ACout2 <os2> -)
#	#(write (crlf) |Clean: | <os2>)
#}
#sp {lib*actr*set*clean*output3
#	:o-support
#	(state <s> ^io.output-link <ol>
#				^AC <a>)
#	(<ol> ^say <os>)
#	(<os> ^out3 <os3>
#		^status complete)
#	(<a> ^ACout3 <os3>)
#-->
#	(<a> ^ACout3 <os3> -)
#	#(write (crlf) |Clean: | <os3>)
#}


# TRANSFER INPUT TO VISUAL
sp {lib*actr*elaborate*visual*in
	(state <s> ^V <v>
				^io.input-link <il>)
	(<il> ^in1 <i1>
		^in2 <i2>
		^in3 <i3>
		^in4 <i4>)
-->
	(<v> ^Vtype <i1>
		^Vword1 <i2>
		^Vword2 <i3>
		^Vline <i4>)
	(write (crlf) |Read: "| <i1> |" "| <i2> |" "| <i3> |" "| <i4> |"|)
}


# TRANSFER QUERIES TO SMEM
sp {lib*actr*elaborate*query*transfer
	(state <s> ^RT <r>
				^smem.command.query <q>)
	(<r> ^<attr> {<val> <> nil <> error <> success})
-->
	#(write (crlf) |Query: | <r1> | | <r2> | | <r3> )
	(<q> ^<attr> <val>)
}

# TRANSFER QUERY RESULTS FROM SMEM
sp {lib*actr*elaborate*query*collect
	#:o-support
	(state <s> ^smem.result.retrieved <sret>
				^RT <r>)
	(<sret> ^{<slot> <> |isa|} <val>)
-->
	(<r> ^<slot> <val> )
}
sp {lib*actr*elaborate*query*collect*replace		#FIXME: removing an i-supported nil
	:o-support
	(state <s> ^smem.result.retrieved <sret>
				^RT <r>)
	(<sret> ^<slot> {<val> <> nil})
	(<r> ^<slot> {<old> << nil error >>})
-->
	(<r> ^<slot> <old> -)
}
sp {lib*actr*elaborate*query*nil
	(state <s> ^smem.result <sres>
			^RT <r>)
	(<sres> -^success
			-^failure)
-->
	(<r> ^result nil
		^slot1 nil
		^slot2 nil
		^slot3 nil)
}
sp {lib*actr*elaborate*query*success
	(state <s> ^smem <smem>
			^RT <r>)
	(<smem> ^result.success
			^command.query.<any>)
-->
	(<r> ^result success)
}
sp {lib*actr*elaborate*query*failure*error
	(state <s> ^smem <smem>
			^RT <r>)
	(<smem> ^result.failure
			^command.query.<any>)
-->
	(<r> ^result error)
}
#sp {lib*actr*elaborate*query*failure*error*nils
#	:o-support
#	(state <s> ^smem <smem>
#			^RT <r>)
#	(<r> ^slot1 error
#		^{<slot> <> slot1} {<val> <> error <> nil})
#-->
#	(<r> ^<slot> <val> -
#		^<slot> nil)
#}
#sp {lib*actr*elaborate*query*failure*error*nils-1
#	:o-support
#	(state <s> ^smem <smem>
#			^RT <r>)
#	(<r> ^slot1 error
#		^slot1 {<val> <> error <> nil})
#-->
#	(<r> ^slot1 <val> -
#		^slot1 nil)
#}
sp {lib*actr*elaborate*query*failure*nil
	(state <s> ^smem <smem>
			^RT <r>)
	(<smem> ^result.failure
			^command.query <cq>)
	(<cq> -^<any> )
-->
	(<r> ^result nil
		^slot1 nil
		^slot2 nil
		^slot3 nil)
}

# FORWARD QUERIES TO RT
sp {lib*actr*set*queries*rt
	:o-support
	(state <s> ^Q <q>
				^RT <r>)
	(<q> ^<slot> <val>)
	(<r> ^<slot> {<old> <> <val>})
-->
	(<r> ^<slot> <old> -
		^<slot> <val>)
	(<q> ^<slot> <val> -)
}
sp {lib*actr*set*queries*rt*remove-q
	:o-support
	(state <s> ^Q <q>
				^RT <r>)
	(<q> ^<slot> <val>)
	(<r> ^<slot> <val>)
-->
	(<q> ^<slot> <val> -)
}

# CLEAN RETRIEVAL BUFFER COMMAND AFTER GETTING RESULT
sp {lib*actr*apply*query*collect*clean					# FIXME: Replacing with o-supported nil
	:o-support
	(state <s> #^operator
			^G <g>
			-^Q.<slot> 
			^RT <r>)
	(<r> ^<slot> {<val> <> nil})
	(<g> ^clear-rt <any>)
-->
	(<r> ^<slot> <val> -)
	#	^<slot> nil)
	(<g> ^clear-rt <any> -)
	#(write (crlf) |CLEAN Q!| (crlf))
}
sp {lib*actr*apply*query*collect*clean*nonil
	:o-support
	(state <s> ^G <g>
			^Q.<slot> <> <val>
			^RT <r>)
	(<r> ^<slot> {<val> <> nil})
	(<g> ^clear-rt <any>)
-->
	(<r> ^<slot> <val> -)
	(<g> ^clear-rt <any> -)
	#(write (crlf) |CLEAN Q!| (crlf))
}
sp {lib*actr*apply*query*collect*clean*nonil*all
	:o-support
	(state <s> ^G <g>
			^Q <q>
			^RT <r>)
	-{(<r> ^<slot> <rval>)
	  (<q> ^<slot> <> <rval>)}
	(<g> ^clear-rt <any>)
-->
	(<g> ^clear-rt <any> -)
	#(write (crlf) |CLEAN Q!| (crlf))
}
# Technically there should be the case where ^clear-rt and all RT == Q, but that won't happen

# NEWWM #
sp {lib*actr*set*newwm*swap
	:o-support
	(state <s> ^NW <n>
				^WM <w>)
	(<n> ^slot1 <n1>
		^slot2 <n2>
		^slot3 {<n3> <> <w>}
		^slot4 <n4>)
-->
	(<s> ^WM <w> -
		^WM <w2>)
	(<w2> ^slot1 <n1>
		^slot2 <n2>
		^slot3 <n3>
		^slot4 <n4>)
	(<n> ^slot1 <n1> -
		^slot2 <n2> -
		^slot3 <n3> -
		^slot4 <n4> -)
}
sp {lib*actr*set*newwm*swap*with-next			# This is just for propose*elio*part-plus-mineral*finish
	:o-support
	(state <s> ^NW <n>
				^WM <w>)
	(<n> ^slot1 <n1>
		^slot2 <n2>
		^slot3 <w>
		^slot4 <n4>)
	(<w> ^slot4 <wmnext>)
-->
	(<s> ^WM <w> -
		^WM <w2>)
	(<w2> ^slot1 <n1>
		^slot2 <n2>
		^slot3 <w>
		^slot4 <n4>)
	(<w> ^slot4 <wmnext> -
		^slot4 <w2>)
	(<n> ^slot1 <n1> -
		^slot2 <n2> -
		^slot3 <w> -
		^slot4 <n4> -)
}
