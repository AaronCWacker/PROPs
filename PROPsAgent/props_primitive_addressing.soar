#####    Author: Bryan Stearns, June 2016
#   When a PROP lacks complete id:attr arguments, a substate finds the instructed memory addresses and returns them to complete the arguments.
#
##		OPERATORS
#   props-sub-begin                         | Initialize the substate
#   props-sub-chain-depth                   | Retrieve the full memory address if necessary (if it's too long to already have by default)
#   props-sub-chain-receive                 | Pull the results of the props-sub-chain-depth query
#   props-sub-chain-iterate                 | Iterate one step through the memory address path
#   props-sub-chain-special-success         | Catch a special case where the PROP tests for WME absence, and the argument path does not exist
#   props-sub-chain-fail                    | Return failure when the WME address path doesn't exist
#   props-sub-return-result                 | Return the pointer to the found WME address if it was successfully found
#   
##      PRIMARY STRUCTURES
#  (<s> ^props-sub (<u>                     | 
#           ^subname <name>                 | The unique name of the LTM instructing this memory address
#           ^symbol <sym>                   | The prop copy used by the parent props-do operator
#           ^sub (<sub>                     | A *copy* of the LTM instructing this memory address, modified in this substate^chain-attr <attr>
#               ^chain-next <next>          | The next node in the linked list of address dot-notation
#               ^curr-id <cid>              | The symbol pointer found by tracing the linked list up to the current point
#               ^curr-attr <cattr>          | The current node in the linked list of address dot-notation (starts at ^sub). When created, triggers iteration.
#               ^target-arg <targ>          | Either of << id1 id2 >> for the needed props-do argument
#               ^target-attr <tattr>        | Either of << attr1 attr2 >> for the needed props-do argument
#               ^depth <d>                  | The length of the memory address chain, in terms of the number of dot-notation segments
#               ^buff-chaining (<buff>
#                   ^id1 <nid1>
#                   ^attr1 <nattr1>
#                   ^id2 <nid2>
#                   ^attr2 <nattr2>)        | A structure that replaces the parent PROP args so it creates the buffered chain rather than the end of the chain
#       ^iterated true                      | Whether at least one iteration has taken place (prereq for proposing to return, more for sanity's sake)
#       ^literalize <l>)                    | A state-global holder for literalizing the iterated chain content
#
#       ^operator (<o>
#           ^name props-sub-chain-iterate
#           ^note << ... >>                 | A var to denote which subclass of iterate operator this is
#           ^sym <sym>                      | The same <sym> as in the state, for convenience and simpler backtracing
#          [^curr-id <cid>
#           ^next-id <next-id>]             | Include these two to iterate the id
#          [^curr-node <node>
#           ^next-node <next-node>]         | Include these to iterate the linked list position (curr-attr)
#          [^ops-id <op>
#           ^ops-attr <attr>
#           ^ops-val <val>
#           ^ops-target <idn>]              | Include these to include a reference to an operator (for a preference)
#          [^buff-id1 <id1>
#           ^buff-id2 <id2>
#           ^buff-attr <attr>
#           ^buff-val2 <val>]               | Include these when iteration traces off the edge of actual WM. Create what doesn't exist in a buffered WM chain, and create a new PROP action to create that chain (<id1> <attr> <val>  <-  <id2> <attr> <val>)
#          [^create-id <id>
#           ^create-attr <attr>
#           ^create-val <val>]              | Include these to create (<id> <attr> <val>), such as when adding on to the end of a buff-chain with further iteration.
#          [^branch-attr <attr>
#           ^branch-id2 <id2>]              | Include these to splice this chain segment onto a previously created bufferred object, if one exists that matches the current <id1>
#           ^literalize <newl>)             | Include to replace the current state <l> with <newl> 

#       ^prop-class                         # << condition action proposal >>
#		^rootstate <rs>
#			^<attr1>
#				^<attr2> ...
#		^superstate.operator
#			^name <prop-name>
#			^symbol <sym>
#       ^const                              # The main instruction set consts (automatically propagated)
#		^symbol <sym>
#				^prop-type					# The PROP type << equality inequality ... add remove acceptable ... >>
#               ^sub                        # The lti-name of the sub lti
#				^id1						# The first id argument - to be filled by this sub-prop if needed
#				^attr1						# The first attribute argument
#				[^id<n>]					# Other numbered id arguments that might need filling
#				[^attr<n>]					# Other numbered attribute arguments
#		^sub <sub>					# A sub-prop head for filling a particular id arg
#			^curr-id					# The current id result
#			^curr-attr					# (created, not loaded) The node of the current place in the attribute chain (starts at ^sub)
#			^depth 						# How many attribute chain elements there are
#			^target-arg					# The id arg being searched for
#			^chain-attr <attr1>			# The first attr in the chain (starting from the rootstate)
#			^chain-next
#				^chain-attr <attr1>
#				^chain-next ...				# Continuous attr chain until at the end id. Value of |done| when no more.
#####


sp {prefer*props*sub*chain*load
    (state <s> ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^name << props-sub-chain-query props-sub-chain-depth props-sub-chain-receive >>)
    (<o2> ^name props-sub-chain-iterate)
-->
    (<s> ^operator <o1> > <o2>)
}
sp {prefer*props*sub*chain*fail
    (state <s> ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^name props-sub-chain-fail)
    (<o2> ^name << props-sub-chain-iterate props-sub-return-result >>)
-->
    (<s> ^operator <o1> > <o2>)
}
sp {prefer*props*sub*chain*iterate
    (state <s> ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^name props-sub-chain-iterate)
    (<o2> ^name props-sub-return-result)
-->
    (<s> ^operator <o1> > <o2>)
}


### OPERATOR ### 
# props-sub-begin
##
# Choose which argument from the parent PROP to evaluate,
# and initialize the state for doing so.
### 

sp {prefer*props*sub*begin
    (state <s> ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^name props-sub-begin)
    (<o2> ^name props-build-proposals)
-->
    (<s> ^operator <o1> > <o2>)
}
sp {prefer*props*sub*begin*arg2
    "Resolve id2 before id1, in case of intermediate augmentations."
    (state <s> ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^name props-sub-begin
          ^ins <ins>
          ^sub <sub1>)
    (<o2> ^name props-sub-begin
          ^ins <ins>
          ^sub <sub2>)
    (<ins> ^sub1-link <sub1>
           ^sub2-link <sub2>)
-->
    (<s> ^operator <o1> < <o2>)
}
#sp {prefer*props*sub*retrieve
#    (state <s> ^operator <o1> +
#               ^operator <o2> +)
#    (<o1> ^name props-sub-r)
#    (<o2> ^name props-sub-begin)
#-->
#    (<s> ^operator <o1> > <o2>)
#}

# PROPOSE A POSSIBLE INITIALIZATION FOR EACH MISSING PROP ARG
sp {propose*props*sub*begin*arg1
	(state <s> ^superstate <ss>
			  -^name)
	(<ss> ^operator <oo>)
		  #^literalize <l>)
	(<oo> ^prop <ins>
          ^proposal <ppl>
          ^name props-do)
	(<ins> ^sub1 <symname>
           ^sub1-link <sub>
		  -^id1)
-->
	(<s> ^operator <o> + = <)
	(<o> ^name props-sub-begin
		^literalize (+ 1 (int <symname>))
		^symname <symname>
        ^proposal <ppl>
		^ins <ins>
        ^sub <sub>)
}
sp {propose*props*sub*begin*arg2
	(state <s> ^superstate <ss>
		      -^name)
	(<ss> ^operator <oo>)
		  #^literalize <l>)
	(<oo> ^prop <ins>
          ^proposal <ppl>
          ^name props-do)
	(<ins> ^sub2 <symname>
           ^sub2-link <sub>
			-^id2)
-->
	(<s> ^operator <o> + = <)
	(<o> ^name props-sub-begin
		^literalize (+ 1 (int <symname>))
		^symname <symname>
        ^proposal <ppl>
        ^ins <ins>
		^sub <sub>)
}
# INITIALIZE THE SUBGOAL TO FIND THE SELECTED MISSING ARG 
sp {apply*props*sub*begin
	(state <s> ^operator <o>
               ^superstate.superstate <sss>)
    (<sss> ^rootstate <rs>)
	(<o> ^name props-sub-begin
		 ^literalize <l>
		 ^symname <symname>
         ^proposal <ppl>
		 ^ins <ins>
         ^sub <sub>)
    (<sub> ^chain-attr <attr>
           ^chain-next <next>
           ^curr-id <cid>
           ^target-arg <targ>
           ^target-attr <tattr>
           ^depth <d>)
-->
	(<s> ^props-sub <u>
         ^evalstate <sss>
         ^rootstate <rs>
         ^proposal <ppl>
         ^literalize (+ 1 (int <attr>) <l>))
    (<u> ^symbol <ins>
         ^sub  <sub-copy>
         ^subname <symname>)
    (<sub-copy> ^chain-attr <attr>
                ^chain-next <next>
                ^curr-id <cid>
                ^target-arg <targ>
                ^target-attr <tattr>
                ^depth <d>)
}

sp {apply*props*sub*begin*proceed
    "If the address chain length is small enough to already be in memory, enable iteration."
    (state <s> ^operator.name props-sub-begin
               ^props-sub.sub <sub>)
    (<sub> -^<attr> props$rootstate
            ^depth <= 2)
-->
    (<sub> ^curr-attr <sub>)
}
sp {apply*props*sub*begin*name
    "Ends the begin operator by naming the substate"
    (state <s> ^operator.name props-sub-begin
               ^props-sub.sub <sub>)
    (<sub> -^<attr> props$rootstate)
-->
    (<s> ^name sub-props)
}

sp {apply*props*sub*begin*bug-catch
    (state <s> ^operator.name props-sub-begin
               ^props-sub <u1>
               ^props-sub <> <u1>)
-->
    (write (crlf) |ERROR: More than one sub being processed.|)
    (halt)
}



### OPERATOR ### 
# props-sub-chain-depth
##
# If the memory address linked list is too long to already be in working memory, fetch the rest of it.
### 

# LOAD THE CHAIN UNTIL THE END IS FOUND (PROPOSE FOR EACH SUB CHAIN)
sp {propose*props*sub*chain*load*depth
	(state <s>	^props-sub <u>
               -^smem.result.<< success failure >>)
    (<u> ^subname <name>
         ^symbol.<sublink> <sub>
        -^sub.curr-attr)
	(<sub> ^depth > 2
           ^lti-name <name>)
-->
	(<s> ^operator <o> + = >)
	(<o> ^name props-sub-chain-depth
		 ^sub <sub>)
}
sp {apply*props*sub*chain*load*depth
	(state <s>	^operator <o>
				^smem.command <scmd>)
	(<o> ^name props-sub-chain-depth
		 ^sub <sub>)
	(<sub> ^depth <d>)
-->
    (<s> ^name sub-props)
	(<scmd>	^retrieve <sub>
			^depth <d>)
}


### OPERATOR ### 
# props-sub-chain-depth
##
# If the memory address linked list is too long to already be in working memory, fetch the rest of it.
### 

# RECEIVE RESULTS - REPLACE OLD OBJECT WITH DEPTH-RETRIEVED VERSION
sp {propose*props*sub*chain*receive*depth
    (state <s>  ^props-sub.sub <sub>
                ^smem <smem>)
    (<smem> ^result.retrieved <lti>
            ^command.retrieve )
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-receive
         ^sub <lti>
         ^oldsub <sub>)
}
sp {apply*props*sub*chain*receive*replace
    (state <s>  ^props-sub <u>
                ^rootstate <rs>
                ^operator <o>)
    (<u> ^sub <sub1>)
    (<o> ^name props-sub-chain-receive
         ^sub <sub2>
         ^oldsub <sub1>)
    (<sub2> ^chain-attr <attr>
            ^chain-next <next>
            ^curr-id <cid>
            ^target-arg <targ>
            ^depth <d>)
-->
    (<u> ^sub <sub1> -
         ^sub <sub2-copy>)
    (<sub2-copy> ^chain-attr <attr>
                 ^chain-next <next>
                 ^curr-attr <sub2-copy>
                 ^curr-id <rs>            # Must always start from rootstate
                 ^target-arg <targ>
                 ^depth <d>)
}

# INFER THE TARGET/NONTARGET ARG ELEMENTS
sp {elaborate*props*sub*chain*target*attr2
    (state <s1> ^props-sub.sub <sub>)
    (<sub> ^target-arg id1)
-->
    (<sub> ^target-attr attr1)
}
sp {elaborate*props*sub*chain*target*attr1
    (state <s1> ^props-sub.sub <sub>)
    (<sub> ^target-arg id2)
-->
    (<sub> ^target-attr attr2)
}




### OPERATOR ### 
# props-sub-chain-iterate
##
# Increment the current place in the declarative linked list of the memory address,
# and update a pointer to the symbol in working memory that results from tracing the list from <s> to that place.
### 

# SET PREFERENCES AMONG ITERATION OPERATORS
sp {prefer*props*sub*iterate*normal
    (state <s> ^props-sub <u>
               ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^name props-sub-chain-iterate
          ^note normal-iteration)
    (<o2> ^name props-sub-chain-iterate
          ^note transfer-chain)
-->
    (<s> ^operator <o1> > <o2>)
}
sp {prefer*props*sub*iterate*non-buff
    (state <s> ^props-sub <u>
               ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^name props-sub-chain-iterate
         -^buff-id1)
    (<o2> ^name props-sub-chain-iterate
          ^buff-id1)
-->
    (<s> ^operator <o1> > <o2>)
}
sp {prefer*props*sub*iterate*transfer
    (state <s> ^props-sub <u>
               ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^name props-sub-chain-iterate
          ^note transfer-chain)
    (<o2> ^name props-sub-chain-iterate
          ^note << create-chain chain-extend >>)
-->
    (<s> ^operator <o1> > <o2>)
}
# If a rootstate operator already exists, the no-exists iteration will also be proposed
# (can't condition on existence negation in superstate for the chunk)
sp {prefer*props*sub*chain*iterate*find*op*exists
    (state <s> ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^name2 iterate-find-operator-mid-exists)
    (<o2> ^name2 iterate-find-operator-mid-new)
-->
    (<s> ^operator <o1> > <o2>)
}

# DO NORMAL ITERATION TO THE NEXT ID POINTED AT IF POSSIBLE
sp {propose*props*sub*chain*iterate*normal
	(state <s> ^props-sub <u>
               ^rootstate <rs>)
	(<u> ^sub <sub>)
	(<sub>	-^curr-attr |done|
			-^status success
			-^status fail)
    # Special conditions:
    (<sub> ^curr-id <id>
           ^curr-attr <node>)
    (<s> ^literalize <l>)
    (<node> ^chain-attr <attr>
            ^chain-next <next-node>)
    (<id> ^<attr> <next-id>
		-^props-agnostic-add )		# Don't follow a link if marked to always make new WMEs
-->
	(<s> ^operator <o> + = >)
	(<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^note normal-iteration 
         ^curr-id <id>
         ^next-id <next-id>
         ^curr-node <node>
         ^next-node <next-node>
         ^literalize (+ 1 (int <l>) (int <attr>)) )
}
# IF AN ADD ACTION MAKES A CHAIN OF WMES AT ONCE, CREATE A BUFFERED WME CHAIN THAT WILL BE ATTACHED TO REGULAR WM WHEN THE ACTION BUFFER IS FLUSHED
# This proposal only gets selected if the iterate*normal proposal does not match.
# Using preferences rather than more-specific conditions keeps certains tests out of the chunks.
sp {propose*props*sub*chain*iterate*create*chain
    (state <s> ^props-sub <u>
               ^rootstate <rs>
               ^evalstate.props-buffer <eb>)
    (<u> ^sub <sub>)
    (<sub>  -^curr-attr |done| 
            -^status success
            -^status fail)
    # Special conditions:
    (<u>  ^symbol <sym>)
    (<sym>  ^prop-type add
           -^intermediate
            ^attr2 <oldattr>)
    (<sub>   ^curr-id <id>
            -^curr-id props$rootstate        # Let replace*keywords do its job first
             ^curr-attr <node>
            -^buff-chaining)
    (<s> ^literalize <l>)
    (<node> ^chain-attr {<attr> <> props$const}
            ^chain-next <next-node>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^note create-chain 
         ^curr-id <id>
         ^next-id <new2>        # Create a new chain after this new object
         ^curr-node <node>
         ^next-node <next-node>
         ^literalize (+ 1 (int <l>) (int <attr>) (int <oldattr>) )
         ^buff-id1 <id>         # Create new prop for adding a buffered object
         ^buff-id2 <new-id1>
         ^buff-attr <attr>
         ^buff-val2 <new>)
    #(write |  *** Buffer creating wme: | <id> | ^| <attr> | | <new> (crlf))
}
# EXTEND A CURRENT BUFFERED CHAIN IF ONE ALREADY EXISTS
# Make new symbols if the chain extension is not copied from other WMEs
sp {propose*props*sub*chain*iterate*create*extend
    (state <s> ^props-sub <u>
               ^rootstate <rs>)
    (<u> ^sub <sub>)
    (<sub>  -^curr-attr |done| 
            -^status success
            -^status fail)
    # Special conditions:
    (<u>  ^symbol <sym>)
    (<sym>    ^prop-type add
              ^intermediate )
    (<sub>  ^curr-id <id>
           -^curr-id props$rootstate        # Let replace*keywords do its job first
            ^curr-attr <node>)
    (<s> ^literalize <l>)
    (<node>  ^chain-attr <attr>
             ^chain-next <next-node>)
    (<id> -^<attr> 
		  -^props-agnostic-add)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^note chain-extend
         ^literalize (+ 1 (int <l>) (int <attr>) )
         ^create-id <id>
         ^create-attr <attr>
         ^create-val <new>
         ^branch-id1 <id>
         ^branch-attr <attr>  # Connect the augmentation chain to the root buffered object at return
         ^branch-id2 <new>)
}
sp {propose*props*sub*chain*iterate*create*extend*agnostic
    (state <s> ^props-sub <u>
               ^rootstate <rs>)
    (<u> ^sub <sub>)
    (<sub>  -^curr-attr |done| 
            -^status success
            -^status fail)
    # Special conditions:
    (<u>  ^symbol <sym>)
    (<sym>    ^prop-type add
              ^intermediate )
    (<sub>  ^curr-id <id>
           -^curr-id props$rootstate        # Let replace*keywords do its job first
            ^curr-attr <node>)
    (<s> ^literalize <l>)
    (<node>  ^chain-attr <attr>
             ^chain-next <next-node>)
    (<id> ^props-agnostic-add )
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^note chain-extend
         ^literalize (+ 1 (int <l>) (int <attr>) )
         ^create-id <id>
         ^create-attr <attr>
         ^create-val <new>
         ^branch-id1 <id>
         ^branch-attr <attr>  # Connect the augmentation chain to the root buffered object at return
         ^branch-id2 <new>)
}
# If the new chain symbols are copied from other WMEs use those instead of new symbols
sp {propose*props*sub*chain*iterate*create*extend*final
    (state <s> ^props-sub <u>
               ^rootstate <rs>)
    (<u> ^sub <sub>)
    (<sub>   ^curr-attr |done| 
            -^status success
            -^status fail)
    # Special conditions:
    (<u>  ^symbol <sym>)
    (<sym>    ^prop-type add
              ^intermediate 
              ^attr1 <attr>
              ^id2 <id2>
              ^attr2 <attr2>)
    (<sub>  ^curr-id <id>
           -^curr-id props$rootstate)        # Let replace*keywords do its job first)
    (<s> ^literalize <l>)
	(<id> -^<attr> 
		  -^props-agnostic-add)
    (<id2> ^<attr2> <val>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^note chain-extend-final
         ^literalize (+ 1 (int <l>) (int <attr>) )
         ^create-id <id>
         ^create-attr <attr>
         ^create-val <val>
         ^branch-id1 <id>
         ^branch-attr <attr>  # Connect the augmentation chain to the root buffered object at return
         ^branch-id2 <id>)
}
sp {propose*props*sub*chain*iterate*create*extend*final*agnostic
    (state <s> ^props-sub <u>
               ^rootstate <rs>)
    (<u> ^sub <sub>)
    (<sub>   ^curr-attr |done| 
            -^status success
            -^status fail)
    # Special conditions:
    (<u>  ^symbol <sym>)
    (<sym>    ^prop-type add
              ^intermediate 
              ^attr1 <attr>
              ^id2 <id2>
              ^attr2 <attr2>)
    (<sub>  ^curr-id <id>
           -^curr-id props$rootstate)        # Let replace*keywords do its job first)
    (<s> ^literalize <l>)
	(<id> ^props-agnostic-add)
    (<id2> ^<attr2> <val>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^note chain-extend-final
         ^literalize (+ 1 (int <l>) (int <attr>) )
         ^create-id <id>
         ^create-attr <attr>
         ^create-val <val>
         ^branch-id1 <id>
         ^branch-attr <attr>  # Connect the augmentation chain to the root buffered object at return
         ^branch-id2 <id>)
}
# REUSE AN EXISTING WME CHAIN IF ONE EXISTS FROM A PREVIOUS PROP MEMORY ADDRESS RESULT
sp {propose*props*sub*chain*iterate*transfer*chain
    (state <s> ^props-sub <u>
               ^rootstate <rs>
               ^evalstate <es>)
    (<u> ^sub <sub>)
    (<sub>  -^curr-attr |done| 
            -^status success
            -^status fail)
    # Special conditions:
    (<u>  ^symbol <sym>)
    (<sym>  ^prop-type add
            ^attr2 <oldattr>)
    (<sub>   ^curr-id <id>
            -^curr-id props$rootstate        # Let replace*keywords do its job first
             ^curr-attr <node>
            -^buff-chaining)
    (<s> ^literalize <l>)
    (<node> ^chain-attr {<attr> <> props$const}
            ^chain-next <next-node>)
    (<es> ^props-buffer.object <ob>)
    (<ob> ^id1 <id>
          ^id1new <idnew>)
    (<idnew> ^<attr> <next-id>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^note transfer-chain
         ^curr-id <id>
         ^next-id <next-id>
         ^curr-node <node>
         ^next-node <next-node>
         ^literalize (+ 1 (int <l>) (int <attr>) (int <oldattr>)) )
}

# ASSUME AN OPERATOR REFERENCE IF A PROPOSAL ACTION USES A BAD ATTRIBUTE
# The special format for referencing operator objects is <s1>.<op-name>, where <op-name> is a constant string.

# CASE 1: The operator reference is at the end of the chain
# Can assume the const number is in the symbol attr argument
sp {propose*props*sub*chain*iterate*find*operator*end
    (state <s> ^props-sub <u>
               ^rootstate <rs>
               ^evalstate.const <const>)
    (<u> ^sub <sub>)
    (<sub>  -^curr-attr |done| 
            -^status success
            -^status fail)
    # Special conditions:
    (<u> ^symbol <sym>)
    (<sym>  ^<tattr> <const-arg>
            ^prop-type proposal)
    (<const> ^<const-arg> <name>)
    (<sub>   ^curr-id <id>
            -^curr-id props$rootstate        # Let replace*keywords do its job first
             ^curr-attr <node>
             ^target-attr <tattr>)
    (<s> ^literalize <l>)
    (<node> ^chain-attr props$const          # This is the marker the default interpreter code gives for const placeholder
            ^chain-next |done|)
-->
    (<s> ^operator <o> + = >)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^curr-node <node>
         ^next-node <next-node>
         ^literalize (+ 1 (int <l>) (int <tattr>) (int <const-arg>) ) # (all three are indeed needed)
         ^ops-id <op-new>
         ^ops-attr name
         ^ops-val <name>
         ^ops-target <tattr>)
}
# CASE 2: The operator reference is in the middle of the chain (<s1>.<op-name>.foo, and the operator already exists
# Find the const number in the chain. 
sp {propose*props*sub*chain*iterate*find*operator*mid*exists
    (state <s> ^props-sub <u>
               ^rootstate <rs>
               ^evalstate.const <const>)
    (<u> ^sub <sub>)
    (<sub>  -^curr-attr |done| 
            -^status success
            -^status fail)
    # Special conditions:
    (<u>  ^symbol <sym>)
    (<sym>  ^prop-type << add remove >>)
    (<sub>   ^curr-id <id>
            -^curr-id props$rootstate        # Let replace*keywords do its job first
             ^curr-attr <node>
             ^target-arg id1
            -^buff-chaining)
    (<s> ^literalize <l>)
    (<node> ^chain-attr props$const          # This is the marker the default interpreter code gives for op-name const placeholder
            ^chain-next {<next> <> |done|})
    (<next> ^chain-attr <const-arg>
            ^chain-next <close>)
    (<const> ^<const-arg> <name>)
    (<id> ^operator <so> +)                  # Case where the operator proposal does already exist
    (<so> ^name <name>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-iterate
         ^name2 iterate-find-operator-mid-exists
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^curr-id <id>
         ^next-id <new-id>
         ^curr-node <node>
         ^next-node <close>
         ^literalize (+ 1 (int <l>) (int <const-arg>) )
         ^buff-id1 <id>
         ^buff-id2 <new-id>
         ^buff-attr operator
         ^buff-val2 <so>)
    #(write |     (Substituting operator: | <so> | ^name | <name> |)| (crlf))
}
# CASE 3: The operator reference is in the middle of the chain, and the operator does not exist (it is being proposed)
# Doesn't explicityly test for absense of operator proposal, because that would get in the chunk.
# If it exists already, the case 2 proposal will be preferred.
sp {propose*props*sub*chain*iterate*find*operator*mid*new
    (state <s> ^props-sub <u>
               ^rootstate <rs>
               ^evalstate.const <const>)
    (<u> ^sub <sub>)
    (<sub>  -^curr-attr |done| 
            -^status success
            -^status fail)
    # Special conditions:
    (<u>  ^symbol <sym>)
    (<sym>  ^prop-type add)
    (<sub>   ^curr-id <id>
            -^curr-id props$rootstate        # Let replace*keywords do its job first
             ^curr-attr <node>
             ^target-arg id1
            -^buff-chaining)
    (<s> ^literalize <l>)
    (<node> ^chain-attr props$const          # This is the marker the default interpreter code gives for op-name const placeholder
            ^chain-next {<next> <> |done|})
    (<next> ^chain-attr <const-arg>
            ^chain-next <close>)
    (<const> ^<const-arg> <name>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-iterate
         ^name2 iterate-find-operator-mid-new
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^curr-id <id>
         ^next-id <new-id>
         ^curr-node <node>
         ^next-node <close>
         ^literalize (+ 1 (int <l>) (int <const-arg>) )
         ^buff-id1 <id>
         ^buff-id2 <new-id>
         ^buff-attr operator
         ^buff-val2 <op-new>
         ^create-id <op-new>
         ^create-attr name
         ^create-val <name>)
    #(write |     (Substituting operator: | <op-new> | ^name | <name> |)| (crlf))
}


### ITERATE FUNCTIONS ###

sp {apply*props*sub*chain*iterate*id
    (state <s>  ^operator <o>)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^curr-id <id>
         ^next-id <next-id>)
    (<sub> ^curr-id <id>)
-->
    (<sub> ^curr-id <id> -
           ^curr-id <next-id>)
}
sp {apply*props*sub*chain*iterate*attr
    (state <s>  ^operator <o>)
    (<sub> ^curr-attr <node>)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^curr-node <node>
         ^next-node <next-node>)
-->
    (<sub> ^curr-attr <node> -
           ^curr-attr <next-node>)
}
sp {apply*props*sub*chain*iterate*literalize
    (state <s>  ^operator <o>)
    (<s> ^literalize <ol>)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^literalize {<l> <> <ol>})
-->
    (<s> ^literalize <ol> -
         ^literalize (+ <ol> <l>) )
}
sp {apply*props*sub*chain*iterate*ops
    (state <s>  ^operator <o>)
    (<o> ^name props-sub-chain-iterate
         ^sym <sym>
         ^literalize <l>
         ^ops-id <op>
         ^ops-attr <attr>
         ^ops-val <val>
         ^ops-target <idn>)    # << attr1 attr2 >>
-->
    (<sym> ^ops <ops>)    # May make messy duplicates, but functional. (For case of better/worse: s.op1 > s.op2)
    (<ops> ^op <op> 
           ^op-target <idn>)
    (<op> ^<attr> <val>)
	#(force-learn <s>)	# (moved to learn_l1) Might learn failures too, but if reaching this point, not likely
}
sp {apply*props*sub*chain*iterate*buff
    (state <s>  ^operator <o>
                ^evalstate.props-buffer <eb>)
   -{(<eb> ^object <on>)
     (<on> ^id1 <id1> ^id1new.<attr> )} # Don't let the chunk make redundant structures
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^sym <sym>
         ^buff-id1 <id1>
         ^buff-id2 <id2>
         ^buff-attr <attr>
         ^buff-val2 <val>)
-->
    (<sub> ^buff-chaining <new-inst>)
    (<new-inst> ^id1 <val>)       # The rest will be created later
    (<sym> ^intermediate true)    # Refers to the rest of the chain, not the new add-object prop created here
    (<eb> ^object <new>     # Create the head of the chain (new object) on the action buffer for shared use with other PROPs
          ^action <prop>)   # Create a new action for adding this object!
    (<new> ^id1 <id1>
		   ^new-prop <prop>
           ^id1new <id2>)   # The placeholder for id1 that gets the chain built onto it
    (<id2> ^<attr> <val>)
    (<prop> ^id1 <id1> ^attr1 <attr> ^id2 <id2> ^attr2 <attr>
            ^prop-type action ^prop-type add 
            ^lti-name (make-constant-symbol |!|)) # TODO: Is name actually needed? If so, m-c-s function not guaranteed unique.
}
sp {apply*props*sub*chain*iterate*create
    (state <s>  ^operator <o>)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^create-id <id>
         ^create-attr <attr>
         ^create-val <val>)
-->
    (<id> ^<attr> <val> )
    #(write |  *** Creating wme: | <id> | ^| <attr> | | <new> (crlf))
}
sp {apply*props*sub*chain*iterate*branch
    (state <s>  ^operator <o>
				#^props-sub.subname <nm>    # Ref here to link in chunk (so not overgeneral; the (<ch>.id1 <val>) test won't make it into chunk)
                ^evalstate.props-buffer <eb>)
    (<o> ^name props-sub-chain-iterate
         ^rootstate <rs>
         ^sub <sub>
         ^branch-id1 <id>                  # TODO: Not needed?
         ^branch-attr <attr>
         ^branch-id2 <id2>)
    (<eb> ^object <bo>)
	(<bo> 	#^new-prop.lti-name <lname>
			^id1new.<oattr> <val>)    	   # Ref here to link in chunk
    (<sub>	^chain-next.chain-attr <oattr>
			^buff-chaining <ch>)
    (<ch> ^id1 <val>                       # Currently iterated to something that already is buffered to be created from a previous addressing routine
         -^id2 )    # Not yet finished initializing
-->
    (<ch> ^attr1 <attr>
          ^id2 <id2>
          ^attr2 <attr>)
	#(<o> ^literalize (+ 1 (int <oattr>)))    # Add another literalization; will happen next elab cycle (after 1st literalization), so no race
}

# MARK THAT SHARED OBJECT MEMORY REFERENCES NEED TO BE MADE PRIOR TO FINAL PROPS RETURN
sp {apply*props*sub*chain*iterate*transferred
    (state <s>  ^operator <o>)
    (<o> ^name props-sub-chain-iterate
         ^note transfer-chain
         ^sym <sym>)
-->
    (<sym> ^intermediate true)
}

# FOR ERROR CHECKING, MARK THAT AN ITERATION HAS OCCURRED (MUST ALWAYS HAPPEN WHEN SUBS INVOKED, ELSE ERROR)
sp {apply*props*sub*chain*iterate*iterated
    (state <s> ^operator.name props-sub-chain-iterate
               ^props-sub <u>)
-->
    (<u> ^iterated true)
}



### OPERATOR ### 
# props-sub-chain-special-success
##
# A special case where not finding the memory address indicates success.
# (If the action is to remove or to test negation)
### 

# If removing something already gone, or doing negation test on it, bypass evaluation by attaching a success flag
sp {propose*props*sub*chain*iterate*special*success
    (state <s> ^props-sub <u>
               ^literalize <l>)
    (<u> ^sub <sub>
         ^symbol <sym>)
    (<sym>    ^prop-type << negation remove >>)    # Special case types
    (<sub>  ^curr-id <id>
           -^curr-id props$rootstate        # Let replace*keywords do its job first
            ^curr-attr <node>)
    (<node>  ^chain-attr <attr>
             ^chain-next <next-node>)
    -(<id> ^<attr> )                        # Attribute doesn't exist
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-special-success
         ^id <id>
         ^attr <attr>
         ^sym <sym>
         ^literalize (+ 1 (int <l>) (int <attr>) ) )
}
sp {apply*props*sub*chain*iterate*special*success
    (state <s> ^operator <o>
               ^proposal <ppl>)
    (<o> ^name props-sub-chain-special-success
         ^id <id>
         ^attr <attr>
         ^sym <sym>
         ^literalize)
-->
    (<sym> ^status success)
    (<ppl> ^original true -)
    (write |  *** Absence success: | <id> | ^| <attr> | already gone.| (crlf))
}


### OPERATOR ### 
# props-sub-chain-fail
##
# The memory address was not found, and the action was not to create.
# The condition being tested is false. (If it's an action, the instructions were malformed, and this is assumed to not be the case.)
# (Operators are treated specially, since operators are referred to by name in PROPs syntax, rather than by "^operator <o>")
### 

# If bad condition reference, return failure to superstate symbol
sp {propose*props*sub*chain*iterate*fail
	(state <s>	^props-sub <u>
                ^rootstate <rs>)
	(<u>   ^symbol <sym>
           ^sub <sub>)
	(<sym>	-^prop-type << action negation >>)	# Special case: lack of chain is success
	(<sub>	-^curr-attr |done| 
            -^status success
            -^status fail
             ^curr-id <id>
			-^curr-id props$rootstate		# Let replace*keywords do its job first
			^curr-attr <node>)
    (<s>  ^literalize <l>)
	(<node>	^chain-attr <attr>
			^chain-next <next-node>)
	-(<id>	^<attr>	)
  -{(<sub> ^curr-id <rs>)
    (<node> ^chain-attr operator)}
  -{(<s> ^operator <o1> +)
    (<o1> ^name props-sub-chain-iterate)}
-->
	(<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-fail
         ^sym <sym>
         ^literalize (+ 1 (int <l>) (int <attr>)) )
}
# Special case: Don't fail on lack of 'operator' when test is for 'operator.something'
sp {propose*props*sub*chain*iterate*fail*operator*aug
    (state <s>  ^props-sub <u>)
    (<u>   ^symbol <sym>
           ^sub <sub>)
    (<sym>    ^<tattr> {<attr> <> name}
             -^prop-type << action negation >>)    # Special case: lack of chain is success
    (<sub>  -^curr-attr |done| 
             ^target-attr <tattr>
            -^status success
            -^status fail
             ^curr-id <id>
            -^curr-id props$rootstate        # Let replace*keywords do its job first
             ^curr-attr <node>)
    (<s>  ^literalize <l>)
    (<node> ^chain-attr operator
            ^chain-next <next-node>)
    -(<id> ^operator.<attr>    )    # Make the chunked test on more than just '^operator'
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-fail
         ^sym <sym>
         ^literalize (+ 1 (int <l>) (int <attr>)) )
}
# Special special case: Don't fail on lack of 'operator.name'. (conflicts with props-fetch-reset) Test a specific name. 
sp {propose*props*sub*chain*iterate*fail*operator*aug*name
    (state <s>  ^props-sub <u>
                ^evalstate.const <const>)
    (<u>   ^symbol <sym>
           ^sub <sub>)
    (<sym>    ^<tattr> name
              ^attr2 <cnum>
              ^id2 <const>
             -^prop-type << action negation >>)    # Special case: lack of chain is success
    (<sub>  -^curr-attr |done| 
             ^target-attr <tattr>
            -^status success
            -^status fail
             ^curr-id <id>
            -^curr-id props$rootstate        # Let replace*keywords do its job first
             ^curr-attr <node>)
    (<s>  ^literalize <l>)
    (<node> ^chain-attr operator
            ^chain-next <next-node>)
    (<const> ^<cnum> <opname>)
    -(<id> ^operator.name <opname> )    # Make the chunked test on more than just '^operator.name'
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-fail
         ^sym <sym>
         ^literalize (+ 1 (int <l>) (int <cnum>)) )
}
# Other special cases: Unsupported at this time. (failed op.name ref test against another sub: s.operator.name = s.foo.bar)
# Print warning
sp {propose*props*sub*chain*iterate*fail*operator*aug*unsupported
    (state <s> ^props-sub <u>
               ^evalstate.const <const>)
    (<u> ^symbol <sym>
         ^sub <sub>)
    (<sym>    ^<tattr> name
              ^attr2 
             -^id1
             -^id2
             -^prop-type << action negation >>)    # Special case: lack of chain is success
    (<sub>  -^curr-attr |done| 
             ^target-attr <tattr>
            -^status success
            -^status fail
             ^curr-id <id>
            -^curr-id props$rootstate        # Let replace*keywords do its job first
             ^curr-attr <node>)
    (<s>  ^literalize <l>)
    (<node> ^chain-attr operator)
    -(<id> ^operator.name  )    # Make the chunk test on more than just '^operator.name'
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-sub-chain-fail
         ^sym <sym>
         ^literalize <l> )
    (write |WARNING: PROPS condition s.operator.name failed due to lack of said structure, when the value 
    tested against uses a dot-notation chain. This is unsupported at this time and could cause infinite loops.| (crlf) )
}

sp {apply*props*sub*chain*iterate*fail
    (state <s> ^operator <o>
               ^proposal <ppl>)
    (<o> ^name props-sub-chain-fail
         ^sym <sym>
         ^literalize)
-->
    (<sym> ^status fail)
    (<ppl> ^original true -)
}




### OPERATOR ### 
# props-sub-return-result
##
# End the impasse by returning the args needed to apply the parent props-do operator (ids and attrs)
### 

sp {propose*props*sub*return*result
	(state <s>	^props-sub <u>
                ^literalize <l>)
	(<u> ^sub <sub>
         ^symbol <sym>
         ^iterated true)    # Assert check that we did iterate
	(<sub> 	^curr-id
			^curr-attr)     # Trace through the literalization
-->
	(<s>	^operator <o> + = >)
	(<o>	^name props-sub-return-result
            ^literalize <l>
            ^sub <sub>
            ^sym <sym>)
}
sp {apply*props*sub*return*result
	(state <s>	^operator <o>
                ^name sub-props
                ^props-sub <u>
                ^literalize <sl>)
    (<o> ^name props-sub-return-result
         ^literalize <l>
         ^sub <sub>
         ^sym <sym>)
	(<sub>	^curr-id <res>
			^target-arg <arg>
			^curr-attr <attr>
           -^buff-chaining)
-->
	(<sym> ^<arg> <res>)
	(<sub> ^curr-attr <attr> -)	# Reset for next time, if this symbol lingers
    (<s> ^props-sub <u> -
		 ^name sub-props -    # End sub props evaluation
         ^literalize <sl> -)
}

# IF SUBBING AN ADD ACTION WITH AN INTERMEDIATE CHAIN, MODIFY THE ACTION TO ADD THE BUFFER RATHER THAN THE LEAF
# CASE 1: id1 is the target
sp {apply*props*sub*return*result*add*buffer*arg1
    (state <s>  ^operator <o>
				^name sub-props
                ^literalize <sl>
                ^props-sub <u>)
    (<o> ^name props-sub-return-result
         ^literalize <l>)
    (<u> ^sub <sub>
         ^symbol <sym>)
    (<sym>  ^prop-type add
           -^id1                  # ^id1 doesn't already exist, so just add it
            ^attr1 <attr1>)
    (<sub>  ^curr-id <res>
            ^curr-attr <curr>
            ^buff-chaining <bc>)
    (<bc> ^id1 <nid1>
          ^attr1 <nattr1>
          ^id2 <nid2>
          ^attr2 <nattr2>)
-->
    (<sym> ^id1 <nid1>            # Modify the instructions to copy the buffer instead of the leaf
           ^attr1 <attr1> -
           ^attr1 <nattr1>
           ^end-id1 <res>
           ^buff-id2 <nid2>
           ^buff-attr2 <nattr2>
           ^oldattr1 <attr1>)
    (<sub> ^curr-attr <curr> -
           ^buff-chaining <ins> -)   # Reset for next time, if this symbol lingers
    (<s> ^props-sub <u> -
		 ^name sub-props -    # End sub props evaluation
         ^literalize <sl> -)
}
sp {apply*props*sub*return*result*add*buffer*arg1*replace
    (state <s>  ^operator <o>
                ^name sub-props
                ^literalize <sl>
                ^props-sub <u>)
    (<o> ^name props-sub-return-result
         ^literalize <l>)
    (<u> ^sub <sub>
         ^symbol <sym>)
    (<sym>  ^prop-type add
            ^id1 <id1>            # ^id1 DOES already exist. So replace it with the buffer chain arg.
            ^attr1 <attr1>)
    (<sub>  ^curr-id <res>
            ^curr-attr <curr>
            ^buff-chaining <bc>)
    (<bc> ^id1 <nid1>
          ^attr1 <nattr1>
          ^id2 <nid2>
          ^attr2 <nattr2>)
-->
    (<sym> ^id1 <id1> -
           ^id1 <nid1>            # Modify the instructions to copy the buffer instead of the leaf
           ^attr1 <attr1> -
           ^attr1 <nattr1>
           ^end-id1 <res>
           ^buff-id2 <nid2>
           ^buff-attr2 <nattr2>
           ^oldattr1 <attr1>)
    (<sub> ^curr-attr <curr> -
           ^buff-chaining <ins> -)   # Reset for next time, if this symbol lingers
    (<s> ^props-sub <u> -
         ^name sub-props -        # End sub props evaluation
         ^literalize <sl> -)
}

