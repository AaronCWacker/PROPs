#####    Author: Bryan Stearns, October 2018
#   This code enables the use of delta sets at the topstate to guide instruction fetching.
#   This is intended to be an alternate to the fixed "manual" task sequence.
#   If sourced, the agent will load an epset (set of deltas / instructions / WM transition descriptions) to match the current task context.
#   This assumes a G.Gtask structure on the topstate, according to the Actransfer model.
#   This is intended to be a temporary assumption until deeper theory provides a more general context source.
#
##        OPERATORS
#   props-load-epset                        | Load a set of deltas for the task
#   props-retrieve-epset                    | Collect the smem retrieval results
#   
##        STRUCTURE
#  (<s> ^G.Gtask <taskname>                 | The source of the epset name (task context)
#       ^props-epset (<pe>                  | The 'buffer' set of deltas
#          [^delta (<d>                     | Corresponds to a single instruction set
#               ^name <name>                | The instruction's name
#               ^application (              | Start of the link to the child application epset
#                   ^unretrieved (          | An intermediate edge, so depth-3 query doesn't default fetch application spread source
#                       ^spread-link <lti>) | The epset to spread to if all conditions are true. This edge should not ever be in WM.
#               ^const <dc>                 | Holds constants for the rule
#              [^prop (<c>             | Corresponds to a single condition of the delta
#                   ^address1 <ts-attr1>    | A cached/provided attribute path from the topstate to find <id1>
#                   ^address2 <ts-attr2>    | A cached/provided attribute path from the topstate to find <id2>
#                   ^prop-type << ... >>    | The operation type
#                   ^id1 <id1>              | The base address for arg1
#                   ^id2 <id2>              | The base address for arg2
#                   ^attr1 <attr1>          | The attribute for arg1
#                   ^attr2 <attr2>          | The attribute for arg2
#                   ^result success)])])    | Created if the condition is true
#####

#source props_epsets_combos.soar

# MANAGE THE PROHIBIT LIST
#sp {elaborate*props*inhibit-list
#    (state <s> ^smem <smem>)
#-->
#    (<smem> ^inhibit-list <pl>)
#    (<pl> ^negate <n>)
#}
sp {elaborate*props*inhibit-list*copy-inhibit
    (state <s> ^superstate.smem.inhibit-list.inhibit <phbt>
               ^smem <smem>)
    (<smem> ^inhibit-list <pl>)
-->
    (<pl> ^inhibit <phbt>)
}
sp {elaborate*props*inhibit-list*copy-negates
    (state <s> ^superstate.smem.inhibit-list.negate <sneg>
               ^smem <smem>)
    (<smem> ^inhibit-list.negate <neg>)
    (<sneg> ^<any> <item>)
-->
    (<neg> ^<any> <item>)
}

sp {elaborate*props*inhibit-list*epset-commands
    "Only use epset prohibits if thats the kind of query in use, else would prohibit activation badly"
    (state <s> ^smem <smem>)
    (<smem> ^inhibit-list.inhibit <p>
            ^command <scmd>)
    (<scmd> -^store
             ^query.props-epset-name )
    (<p> ^props-epset-name ) 
-->
    (<scmd> ^prohibit <p>)
}
sp {elaborate*props*inhibit-list*deltas
    (state <s> ^smem <smem>)
    (<smem> ^inhibit-list.inhibit <p>
            ^command <scmd>)
    (<scmd> -^store)
    (<p> ^prop ) 
-->
    (<scmd> ^prohibit <p>)
}
sp {elaborate*props*inhibit-list*negations
    (state <s> ^smem <smem>)
    (<smem> ^inhibit-list.negate <neg>
            ^command <scmd>)
    (<scmd> -^store)
   -{(<neg> -^<attr> )} # There is something to negate
-->
   (<scmd> ^neg-query <neg>)
}

# PROPAGATE THE TOPSTATE
sp {elaborate*topstate
    (state <s> ^superstate nil)
-->
    (<s> ^topstate <s>)
}
sp {elaborate*rootstate*cascade
    (state <s> ^superstate.topstate <ts>)
-->
    (<s> ^topstate <ts>)
}

# INHERIT CONST STRUCTS FROM SUPERSTATE EPSETS
sp {elaborate*superstate-epset*consts
    (state <s> ^superstate.props-epset.const <c>)
-->
    (<s> ^const <c>)
}
sp {elaborate*superstate*consts
    (state <s> ^superstate.const <c>)
-->
    (<s> ^const <c>)
}

# GIVE EACH SUBSTATE AN APPLY BUFFER IN WHICH TO STAGE BATCH RESULTS
sp {elaborate*apply-buffer
    (state <s> ^type state)
-->
    (<s> ^prop-apply-buffer <b>
         ^locks <k>)
}
sp {elaborate*apply-buffer*working-apply
    "Make the empty apply structure that substate application ops will build onto."
    (state <s> ^prop-apply-buffer <b>
               ^superstate {<ss> <> nil})
-->
    (<b> ^apply <a>)
    # If we've entered an impasse, we need to chunk this state before chunking the superstate.
    (dont-learn <ss>)
}

# PROHIBIT EPSETS AND DELTAS CURRENTLY IN USE UP STATE STACK
sp {elaborate*props*epset*prohibit-used
    (state <s> ^props-epset <ep>
               ^smem.inhibit-list <pl>)
-->
    (<pl> ^inhibit <ep>)
}
sp {elaborate*props*delta*prohibit-used
    (state <s> ^props-epset.delta <d>
               ^set-applied.item-name <dname>
               ^smem.inhibit-list <pl>)
    (<d> ^prop.name <dname>)
-->
    (<pl> ^inhibit <d>)
}

# RESET THE BUFFER ON TASK FINISH
sp {lib*actr*apply*finish*apply-buffer
    (state <s> ^operator.name actransfer-finish
                ^prop-apply-buffer <b>)
    (<b> ^apply <a>)
-->
    # Reset buffers
    (<b> ^apply <a> - )
}

### OPERATOR ### 
# props-load-epset
##
# Recall info needed to support the PROPs processing 
### 

sp {propose*props*eval*query*epset*topstate
    "Load an epset to bias fetching for the task"
    (state <s> ^G.Gtask {<task> <> finish}    # Finish triggers interface response
              -^smem.result.<< retrieved failure >>
              -^props-epset.props-epset-name <task>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-load-epset
         ^epset-name <task>)
}
sp {propose*props*eval*query*epset*substate
    "Load an epset to apply a parent delta (operator)"
    (state <s> ^superstate.operator <oo>
               ^impasse no-change
               ^attribute operator
              -^smem.result.<< retrieved failure >>
              -^props-epset)
    (<oo> ^delta 
         ^name <name>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-load-epset
         ^epset-name <name>)        # Remove this line for free epset retrievals (should then prohibit used epsets for a time though)
    #(force-learn <s>)
}

sp {apply*props*eval*query*epset*task-named
    (state <s> ^operator <o>
               ^smem.command <scmd>)
    (<o> ^name props-load-epset
         ^epset-name <name>)
-->
    (<scmd> ^query <q>
            ^depth 3)
    (<q> ^props-epset-name <name>)
}
sp {apply*props*eval*query*epset*task-unnamed
    (state <s> ^operator <o>
               ^smem.command <scmd>)
    (<o> ^name props-load-epset
         -^epset-name <name>)
-->
    (<scmd> ^query <q>
            ^depth 3)
    (<q> ^props-epset-name <any>)
}


### OPERATOR ### 
# props-retrieve-epset
##
# Pull the query result
### 

sp {propose*props*retrieve-epset
    (state <s> ^smem.result.retrieved <e>
              -^props-epset.props-epset-name <name>)
    (<e> ^props-epset-name <name>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-retrieve-epset)
}
sp {elaborate*props*retrieve-epset*failure
    (state <s> ^smem.result.failure <q>
               ^topstate.io.output-link <ol>)
    (<q> ^props-epset-name )
-->
    (<ol> ^error <e>)
    (<e> ^msg |EPSET RETRIEVAL FAILED| )
    (write |EPSET RETRIEVAL FAILED| (crlf) )
    (interrupt)
}

sp {apply*props*retrieve-epset*success*new
    (state <s> ^operator.name props-retrieve-epset
               ^smem <smem>
              -^props-epset)
    (<smem> ^command <scmd>
           ^result.retrieved <e>)
    (<scmd> ^query <q>)
-->
    (force-learn <s>)
    (<s> ^props-epset <e>)
    (<scmd> ^query <q> -)
}
sp {apply*props*retrieve-epset*success*replace
    (state <s> ^operator.name props-retrieve-epset
               ^smem <smem>
               ^props-epset {<olde> <> <e>})
    (<smem> ^command <scmd>
           ^result.retrieved <e>)
    (<scmd> ^query <q>)
-->
    (force-learn <s>)
    (<s> ^props-epset <e>
         ^props-epset <olde> -)
    (<scmd> ^query <q> -)
}

# FOR LEARNING NEW EPSETS:
#sp {apply*props*retrieve-epset*failure*task-named
#    "On failure, make a new empty epset"
#    (state <s> ^operator <o>
#               ^G.Gtask <taskname>
#               ^smem (^command <scmd> ^result.failure) )
#    (<o> ^name props-retrieve-epset)
#    (<scmd> ^query <q>)
#-->
#    (<s> ^props-epset <enew>)
#    (<enew> ^props-epset-name <taskname>)
#    (<scmd> ^store <enew>
#            ^query <q> -)
#}
#sp {apply*props*retrieve-epset*failure*task-unnamed
#    "On failure, make a new empty epset"
#    (state <s> ^operator <o>
#               -^io.input-link.task-sequence-name
#               ^smem (^command <scmd> ^result.failure) )
#    (<o> ^name props-retrieve-epset)
#    (<scmd> ^query <q>)
#-->
#    (<s> ^props-epset <enew>)
#    (<enew> ^props-epset-name |unnamed|)
#    (<scmd> ^store <enew>
#            ^query <q> -)
#}
#sp {set*props*retrieve-epset*clean-store
#    :o-support
#    (state <s> ^props-epset <pe>
#               ^smem <smem>)
#    (<smem> ^command <sc>
#            ^result.<< success failure >> <pe>)
#    (<sc> ^store <pe>)
#-->
#    (<sc> ^store <pe> -)
#}

### OPERATOR ### 
# (props-init-evaluation)
##
# Create epset items for the current instructions if they don't yet exist.
# (props-init-evaluation) defined in props_instruction_init.soar.
### 
#sp {apply*props*init-evaluation*epset*create-delta
#    "Create an instruction delta reference if it doesnt yet exist."
#    (state <s> ^operator <o>
#               ^quiescence t
#               ^rootstate <rs>)
#    (<o> ^name props-init-evaluation
#         ^props-instructions <ins>)
#    (<ins> ^name <name>
#           ^const <consts>)
#    (<rs> ^props-epset <pe>)
#    -{(<pe> ^delta <d>)
#      (<d> ^name <name>)}         # It is not the case that the current epset has these instructions
#-->
#    (<pe> ^delta <dnew>)
#    (<dnew> ^name <name>
#            ^spread-id (@ <ins>)
#            ^elabs <enew>
#            ^const <cnew>)        # Make a separate copy of consts, so isn't an intermediate result that confuses chunking
#    (<s> ^props-to-store <dnew>
#         ^props-to-store <pe>)    # Mark for storing after init-evaluation completes
#}
#sp {apply*props*init-evaluation*epset*create-delta*copy-consts
#    "Copy to the superstate delta struct any consts from these instructions."
#    (state <s> ^operator <o>
#               ^quiescence t
#               ^rootstate <rs>)
#    (<o> ^name props-init-evaluation
#         ^props-instructions <ins>)
#    (<ins> ^name <name>
#           ^const <consts>)
#    (<rs> ^props-epset.delta <d>)
#    (<d> ^const <c>)
#    (<consts> ^<attr> <val>)
#    (<c> -^<attr> <val>)
#-->
#    (<c> ^<attr> <val>)
#}
#sp {apply*props*init-evaluation*epset*create-delta*condition*1arg
#    "Create a delta condition if it doesnt yet exist."
#    (state <s> ^operator <o>
#               ^quiescence t
#               ^rootstate <rs>)
#    (<o> ^name props-init-evaluation
#         ^props-instructions <ins>)
#    (<ins> ^name <name>
#           ^prop <cname>
#           ^prop-link <pl>)
#    (<pl> ^lti-name <cname>
#          ^prop-type {<type> <> |condition|}
#          ^attr1 <attr1>
#          -^attr2)
#    (<rs> ^props-epset.delta <d>)
#    (<d> ^name <name>)
#    -{(<d> ^prop <cond>)
#      (<cond> ^lti-name <cname>)}  # It is not the case that this delta has this condition recorded
#-->
#    (<d> ^prop <cnew>)
#    (<cnew> ^lti-name <cname>
#            ^prop-type <type>
#            ^elabs <enew>
#            ^attr1 <attr1>)
#    (<s> ^props-to-store <cnew>)    # Mark it for storing after init-evaluation completes
#}
#sp {apply*props*init-evaluation*epset*create-delta*condition*2arg
#    "Create a delta condition if it doesnt yet exist."
#    (state <s> ^operator <o>
#               ^quiescence t
#               ^rootstate <rs>)
#    (<o> ^name props-init-evaluation
#         ^props-instructions <ins>)
#    (<ins> ^name <name>
#           ^prop <cname>
#           ^prop-link <pl>)
#    (<pl> ^lti-name <cname>
#          ^prop-type {<type> <> |condition|}
#          ^attr1 <attr1>
#          ^attr2 <attr2>)
#    (<rs> ^props-epset.delta <d>)
#    (<d> ^name <name>)
#    -{(<d> ^prop <cond>)
#      (<cond> ^lti-name <cname>)}  # It is not the case that this delta has this condition recorded
#-->
#    (<d> ^prop <cnew>)
#    (<cnew> ^lti-name <cname>
#            ^prop-type <type>
#            ^elabs <enew>
#            ^attr1 <attr1>
#            ^attr2 <attr2>)
#    (<s> ^props-to-store <cnew>)    # Mark it for storing after init-evaluation completes
#}

#sp {apply*props*init-evaluation*epset*create-delta*condition*address1
#    "Create condition address info if it doesnt yet exist."
#    (state <s> ^operator <o>
#               ^quiescence t
#               ^rootstate <rs>)
#    (<o> ^name props-init-evaluation
#         ^props-instructions <ins>)
#    (<ins> ^name <name>
#           ^prop <cname>
#           ^prop-link (^lti-name <cname> ^sub1-link.chain-attr <addr>) )
#    (<rs> ^props-epset.delta <d>)
#    (<d> ^name <name>
#         ^prop <cond>)
#    (<cond> ^lti-name <cname>
#           -^address1)
#-->
#    (<cond> ^address1 <addr>)
#}
#sp {apply*props*init-evaluation*epset*create-delta*condition*address2*provided
#    "Create condition address info if it doesnt yet exist."
#    (state <s> ^operator <o>
#               ^quiescence t
#               ^rootstate <rs>)
#    (<o> ^name props-init-evaluation
#         ^props-instructions <ins>)
#    (<ins> ^name <name>
#           ^prop <cname>
#           ^prop-link (^lti-name <cname> ^sub2-link.chain-attr <addr>) )
#    (<rs> ^props-epset.delta <d>)
#    (<d> ^name <name>
#         ^prop <cond>)
#    (<cond> ^lti-name <cname>
#           -^address2)
#-->
#    (<cond> ^address2 <addr>)
#}
#sp {apply*props*init-evaluation*epset*create-delta*condition*address2*const
#    "Create condition address info if it doesnt yet exist."
#    (state <s> ^operator <o>
#               ^quiescence t
#               ^rootstate <rs>)
#    (<o> ^name props-init-evaluation
#         ^props-instructions <ins>)
#    (<ins> ^name <name>
#           ^prop <cname>
#           ^prop-link <pl>)
#    (<pl> ^lti-name <cname>
#          ^attr2 
#         -^sub2-link)
#    (<rs> ^props-epset.delta <d>)
#    (<d> ^name <name>
#         ^const <const> 
#         ^prop <cond>)
#    (<cond> ^lti-name <cname>
#           -^address2)
#-->
#    (<cond> ^address2 |constant|)
#}

# OVERWRITES FROM props_instruction_init.soar
#sp {apply*props*init-evaluation*originals-ready
#    "Wait until delta is created before ending"
#    (state <s> ^operator.name props-init-evaluation
#               ^rootstate.props-epset <pe>
#               ^smem.command <scmd>
#              -^props-to-store
#               ^props-flag originals-not-ready
#               ^props-buffer)
#   (<pe> ^delta.prop.address1 <any>)
#-->
#    (<s> ^props-flag originals-not-ready -)
#}
#sp {apply*props*init-evaluation*originals-ready*store-new
#    "Store any newly created epset augmentations"
#    (state <s> ^operator.name props-init-evaluation
#               ^rootstate.props-epset <pe>
#               ^smem.command <scmd>
#               ^props-to-store <new>
#               ^props-buffer)
#-->
#    (<scmd> ^store <new>)
#    (<s> ^props-to-store <new> -)
#}


### 
# Propose matching rule descriptions in the epset
###

sp {propose*props*epset*delta*condition*all-true
    "Propose the operator if all conditions are true."
    (state <s> ^props-epset <pe>)
    (<pe> ^delta <d>)
    (<d> ^op-name <name>
        -^prop-apply)    # Only for conditions
    -{(<d> ^prop.name <cname>
          -^cond-success <cname>)} # It is not the case that this delta has untrue conditions
-->
    (<s> ^operator <o> + )    # Make indifferent to bypass proposal composition
    (<o> ^name <name>
         ^delta <d>)
}
sp {propose*props*epset*delta*action*all-true
    "Propose the operator if it hasnt been applied yet."
    (state <s> ^props-epset <pe>
              -^no-propose <d>    # Not if this was just created and about to be stored
               ^prop-apply-buffer <pb>)
    (<pe> ^delta <d>)
    (<d> ^prop-apply           # Only for actions
         ^op-name <dname>)
    -{(<pb> ^apply.delta-action.name <name>)
      (<d> ^item-name <name>)}  # It is not the case that this operator contains used actions
-->
    (<s> ^operator <o> + > =)    # Make indifferent to bypass proposal composition
    (<o> ^name <dname>
         ^delta <d>)
}

sp {prefer*props*epset*delta*larger
    "Prefer deltas that subsume other deltas"
    (state <s> ^operator <o1> +
               ^operator <o2> +)
    (<o1> ^delta.source-delta <d>)
    (<o2> ^delta <d>)
-->
    (<s> ^operator <o1> > <o2>)
}


### 
# Elaborate upon matching rule descriptions in the epset to stimulate spread
###

#sp {elaborate*props*epset*delta*all-true*spread
#    "Create a spreader if all conditions are true"
#    (state <s> ^props-epset <pe>)
#    (<pe> ^delta <d>)
#    (<d> ^application.unretrieved <lti>
#         ^cond-id1 <any>         # To make sure this doesn't fire before conditions can be evaluated
#        -^missing )
#    -{(<d> ^prop <c>
#           ^cond-id1 <cid1>)
#      (<c> ^name <cname>)
#      (<cid1> -^result success)} # It is not the case that this delta has untrue conditions
#-->
#    (<lti> ^active-spread <cname>)        # some augmentation just to allow spread
#}
#sp {elaborate*props*epset*delta*all-true
#    "Create a spreader if all conditions are true"
#    (state <s> ^props-epset <pe>)
#    (<pe> ^delta <d>)
#    (<d> ^instructions.spread-id <ltinum>)
#    -{(<d> ^prop <c>)
#      (<c> -^result success)} # It is not the case that this delta has untrue conditions
#-->
#    (<d> ^result success
#         ^spreader <xs>)
#    (<xs> ^spread-id <ltinum>)        # some augmentation just to allow spread
#    (link-stm-to-ltm <xs> <ltinum>)
#}    # Use this instead if spread-id is a number only rather than an lti

sp {apply*props*cbset*add
    (state <s> ^operator <o>
               ^prop-apply-buffer.apply <ba>)
    (<o> ^delta <d>)
    (<d> ^prop <a>
         ^op-name <dname>
         ^cond-id1 (^id1 <id1> ^name <cname> )
         ^cond-id2 (^id2 <id2> ^name <cname> ) )
    (<a> ^prop-type add
         ^name <cname>
         ^attr1 <attr1>
         ^attr2 <attr2>)
    (<id2> ^<attr2> <val>)
-->
    (<ba> ^delta-action <dnew>)
    (<dnew> ^prop-type add
            ^name <cname>
            ^id1 <id1>
            ^attr1 <attr1>
            ^val <val>)
    (<s> ^set-applied <anew>
         ^combine-cbset <dname>)    # Make single combo entry. If is only one, combine will skip
    (<anew> ^item-name <cname>
            ^set-name <dname>)
}
sp {apply*props*cbset*remove
    (state <s> ^operator <o>
               ^prop-apply-buffer.apply <ba>)
    (<o> ^delta <d>)
    (<d> ^prop <a>
         ^op-name <dname>
         ^cond-id1 (^id1 <id1> ^name <cname> ) )
    (<a> ^prop-type remove
         ^name <cname>
         ^id1 <id1>
         ^attr1 <attr1>)
-->
    (<ba> ^delta-action <dnew>)
    (<dnew> ^prop-type remove
            ^name <cname>
            ^id1 <id1>
            ^attr1 <attr1>)
    (<s> ^set-applied <anew>
         ^combine-cbset <dname>)
    (<anew> ^item-name <cname>
            ^set-name <dname>)
}

# SUPPLY CACHED ADDRESSES:

sp {elaborate*props*epset*delta*cond*address1*buffer
    (state <s> ^props-epset (^delta <d> -^generated )
              #-^smem.command.store <c>    # don't include the id in smem
              -^no-propose <d>         # don't bother for new action deltas
               ^topstate.<buff> <buff-id>)
    (<d> ^prop <c>)
    (<c> ^address1 <buff>
         ^name <cname>)
-->
    (<d> ^cond-id1 <dcid>)
    (<dcid> ^name <cname>
            ^id1 <buff-id>)
}
sp {elaborate*props*epset*delta*cond*address2*buffer
    (state <s> ^props-epset (^delta <d> -^generated )
              #-^smem.command.store <c>    # don't include the id in smem
              -^no-propose <d>         # don't bother for new action deltas
               ^topstate.<buff> <buff-id>)
    (<d> ^prop <c>)
    (<c> ^address2 <buff>
         ^name <cname>)
-->
    (<d> ^cond-id2 <dcid>)
    (<dcid> ^name <cname>
            ^id2 <buff-id>)
}
sp {elaborate*props*epset*delta*cond*address2*cond-const
    (state <s> ^props-epset (^delta <d> -^generated ) )
    (<d> ^const <dc>
         ^prop <c>)
    (<c> ^address2 |props$const|
         ^name <cname>)
-->
    (<d> ^cond-id2 <dcid>)
    (<dcid> ^name <cname>
            ^id2 <dc>)
}
sp {elaborate*props*epset*delta*cond*address2*act-const
    (state <s> ^props-epset <pe>
              -^no-propose <d>         # don't bother for new action deltas
               ^const <dc>)
    (<pe> ^delta <d>
         -^generated)
    (<d> ^prop <c>)
    (<c> ^address2 |props$const|
         ^name <cname>)
-->
    (<d> ^cond-id2 <dcid>)
    (<dcid> ^name <cname>
            ^id2 <dc>)
}
sp {elaborate*props*epset*delta*cond*address1*rootstate
    (state <s> ^props-epset <pe>
              -^no-propose <d>         # don't bother for new action deltas
               ^topstate <ts>)
    (<pe> ^delta <d>
          -^generated)
    (<d> ^prop <c>)
    (<c> ^address1 |props$rootstate|
         ^name <cname>)
-->
    (<d> ^cond-id1 <dcid>)
    (<dcid> ^name <cname>
            ^id1 <ts>)
}
sp {elaborate*props*epset*delta*cond*address2*rootstate
    (state <s> ^props-epset <pe>
              -^no-propose <d>         # don't bother for new action deltas
               ^topstate <ts>)
    (<pe> ^delta <d>
          -^generated )
    (<d> ^prop <c>)
    (<c> ^address2 |props$rootstate|
         ^name <cname>)
-->
    (<d> ^cond-id2 <dcid>)
    (<dcid> ^name <cname>
            ^id2 <ts>)
}

sp {elaborate*props*epset*delta*cond*address1*missing
    (state <s> ^props-epset (^delta <d> -^generated )
              -^topstate.<buff> <buff-id>)
    (<d> ^prop <c>)
    (<c> ^address1 {<buff> <> |props$rootstate|})
-->
    (<d> ^missing |id1|)
}
sp {elaborate*props*epset*delta*cond*address2*missing*buffer
    (state <s> ^props-epset (^delta <d> -^generated )
              -^topstate.<buff> <buff-id>)
    (<d> ^prop <c>)
    (<c> ^address2 {<buff> <> |props$const| <> |props$rootstate|})
-->
    (<d> ^missing |id2|)
}


### EPSET PRELS: (PRimitive ELabs)

# CONDITIONS

sp {elaborate*props*epset*delta*cond*eq
    (state <s> ^props-epset.delta <d>)
    (<d> ^prop <c>
         ^cond-id1 <cid1>
         ^cond-id2 <cid2>)
    (<cid1> ^name <cname>
            ^id1 <id1>)
    (<cid2> ^name <cname>
            ^id2 <id2>)
    (<c> ^prop-type equality
         ^name <cname>
         ^attr1 <attr1>
         ^attr2 <attr2>)
    (<id1> ^<attr1> <val>)
    (<id2> ^<attr2> <val>)
-->
    (<d> ^cond-success <cname>)
}
sp {elaborate*props*epset*delta*cond*neq
    (state <s> ^props-epset.delta <d>)
    (<d> ^prop <c>
         ^cond-id1 <cid1>
         ^cond-id2 <cid2>)
    (<cid1> ^name <cname>
            ^id1 <id1>)
    (<cid2> ^name <cname>
            ^id2 <id2>)
    (<c> ^prop-type inequality
         ^name <cname>
         ^attr1 <attr1>
         ^attr2 <attr2>)
    (<id1> ^<attr1> <val>)
    (<id2> ^<attr2> <> <val>)
-->
    (<d> ^cond-success <cname>)
}
sp {elaborate*props*epset*delta*cond*teq
    (state <s> ^props-epset.delta <d>)
    (<d> ^prop <c>
         ^cond-id1 <cid1>
         ^cond-id2 <cid2>)
    (<cid1> ^name <cname>
            ^id1 <id1>)
    (<cid2> ^name <cname>
            ^id2 <id2>)
    (<c> ^prop-type type-equality
         ^name <cname>
         ^attr1 <attr1>
         ^attr2 <attr2>)
    (<id1> ^<attr1> <val>)
    (<id2> ^<attr2> <=> <val>)
-->
    (<d> ^cond-success <cname>)
}
sp {elaborate*props*epset*delta*cond*less
    (state <s> ^props-epset.delta <d>)
    (<d> ^prop <c>
         ^cond-id1 <cid1>
         ^cond-id2 <cid2>)
    (<cid1> ^name <cname>
            ^id1 <id1>)
    (<cid2> ^name <cname>
            ^id2 <id2>)
    (<c> ^prop-type less-than
         ^name <cname>
         ^attr1 <attr1>
         ^attr2 <attr2>)
    (<id1> ^<attr1> < <val>)
    (<id2> ^<attr2> <val>)
-->
    (<d> ^cond-success <cname>)
}
sp {elaborate*props*epset*delta*cond*greater
    (state <s> ^props-epset.delta <d>)
    (<d> ^prop <c>
         ^cond-id1 <cid1>
         ^cond-id2 <cid2>)
    (<cid1> ^name <cname>
            ^id1 <id1>)
    (<cid2> ^name <cname>
            ^id2 <id2>)
    (<c> ^prop-type greater-than
         ^name <cname>
         ^attr1 <attr1>
         ^attr2 <attr2>)
    (<id1> ^<attr1> > <val>)
    (<id2> ^<attr2> <val>)
-->
    (<d> ^cond-success <cname>)
}
sp {elaborate*props*epset*delta*cond*less-equal
    (state <s> ^props-epset.delta <d>)
    (<d> ^prop <c>
         ^cond-id1 <cid1>
         ^cond-id2 <cid2>)
    (<cid1> ^name <cname>
            ^id1 <id1>)
    (<cid2> ^name <cname>
            ^id2 <id2>)
    (<c> ^prop-type less-equal
         ^name <cname>
         ^attr1 <attr1>
         ^attr2 <attr2>)
    (<id1> ^<attr1> <= <val>)
    (<id2> ^<attr2> <val>)
-->
    (<d> ^cond-success <cname>)
}
sp {elaborate*props*epset*delta*cond*greater-equal
    (state <s> ^props-epset.delta <d>)
    (<d> ^prop <c>
         ^cond-id1 <cid1>
         ^cond-id2 <cid2>)
    (<cid1> ^name <cname>
            ^id1 <id1>)
    (<cid2> ^name <cname>
            ^id2 <id2>)
    (<c> ^prop-type greater-equal
         ^name <cname>
         ^attr1 <attr1>
         ^attr2 <attr2>)
    (<id1> ^<attr1> <= <val>)
    (<id2> ^<attr2> <val>)
-->
    (<d> ^cond-success <cname>)
}
#sp {elaborate*props*epset*delta*cond*inexistence
#    (state <s> ^props-epset.delta <d>)
#    (<d> ^prop <c>
#         ^cond-id1 <cid1>)
#    (<cid1> ^name <cname>
#            ^id1 <id1>)
#    (<c> ^prop-type inexistence
#         ^name <cname>
#         ^attr1 <attr1>)
#    (<id1> -^<attr1> <val>)
#-->
#    (<d> ^cond-success <cname>)
#}
sp {elaborate*props*epset*delta*cond*negation
    (state <s> ^props-epset.delta <d>)
    (<d> ^prop <c>
         ^cond-id1 <cid1>)
    (<cid1> ^name <cname>
            ^id1 <id1>)
    (<c> ^prop-type negation
         ^name <cname>
         ^attr1 <attr1>)
    (<id1> -^<attr1> <val>)
-->
    (<d> ^cond-success <cname>)
}
sp {elaborate*props*epset*delta*cond*existence
    (state <s> ^props-epset.delta <d>)
    (<d> ^prop <c>
         ^cond-id1 <cid1>)
    (<cid1> ^name <cname>
            ^id1 <id1>)
    (<c> ^prop-type existence
         ^name <cname>
         ^attr1 <attr1>)
    (<id1> ^<attr1> <val>)
-->
    (<d> ^cond-success <cname>)
}


# ACTIONS (COMPLEMENTARY CONDITIONS FOR ACTIONS)

sp {elaborate*props*epset*delta*action*available
    "The proposal condition for actions is that they are not yet on the return buffer."
    (state <s> ^props-epset.delta <d>
               ^prop-apply-buffer <b>)
    (<b> -^apply.delta-action.name <cname>)
    (<d> ^prop-apply 
         ^prop <c>)
    (<c> ^name <cname>)
-->
    (<d> ^cond-success <cname>)
}

### Stimulate spread from all unapplied actions to their relevant apply structures
sp {elaborate*props*cbset*apply*spread
    "Create a spreader if not yet applied"
    (state <s> ^props-epset <pe>
              -^cbset-combine-done true  # Don't let the active-spread wme get saved to smem
               ^prop-apply-buffer <ab>)
    (<pe> ^delta <a>)
    (<ab> -^apply.delta-action.name <aname>)
    (<a> ^application.unretrieved <lti>
         ^prop-apply
         ^op-name <aname>)
-->
    (<lti> ^active-spread <aname>)        # some augmentation just to allow spread
}


### OPERATOR ### 
# props-load-cbset
##
# Fetch a cbset of applications, based on spread from available actions.
# The retrieved set will include one or more actions to apply in parallel.
### 

sp {propose*props*delta*query
    "Load a delta to apply a parent epset (operator)"
    (state <s> ^superstate <ss>
               ^impasse tie
               #^item <i>
              -^smem.result.<< retrieved failure >>
              -^selected-delta )
    #(<ss> ^prop-apply-buffer <b>)
    #(<i> ^delta.op-name <name>)
    #(<b> -^delta-action.name <name>)
-->
    (<s> ^operator <o> + > =)
    (<o> ^name props-load-delta)
}
sp {apply*props*delta*query
    (state <s> ^operator <o>
               ^smem.command <scmd>)
    (<o> ^name props-load-delta)
-->
    (<scmd> ^query <q>
            #^neg-query <neg>
            ^depth 3)
    (<q> ^prop <any>    # Any apply delta, even higher level op compositions
         ^prop-apply <any2>)
}
# ADD NEG-QUERY ITEMS PER USED PROP ACTION
#sp {apply*props*delta*query*negate-used
#    (state <s> ^operator <o>
#               ^superstate.props-flag apply-buffer-nonempty
#               ^smem.command <scmd>)
#    (<o> ^name props-load-delta)
#    (<scmd> -^neg-query )
#-->
#    (<scmd> ^neg-query <neg>)
#}
sp {apply*props*delta*query*negate-used*item
    (state <s> ^operator <o>
               ^superstate.set-applied.item-name <name>
               ^smem.inhibit-list <pl>)
    (<o> ^name props-load-delta)
    (<pl> ^negate <neg>)
-->
    (<neg> ^item-name <name>)
}

### OPERATOR ### 
# props-retrieve-cbset
##
# Pull the query result
### 

sp {propose*props*retrieve-delta
    (state <s> ^smem <smem>
              -^selected-delta )
    (<smem> ^result.retrieved <d>
            ^command.query.prop )
-->
    (<s> ^operator <o> + >)
    (<o> ^name props-retrieve-delta)
}
sp {elaborate*props*retrieve-delta*failure
    (state <s> ^smem.result.failure <q>
               ^topstate.io.output-link <ol>)
    (<q> ^prop )
-->
    (<ol> ^error <e>)
    (<e> ^msg |DELTA RETRIEVAL FAILED| )
    (write |DELTA RETRIEVAL FAILED| (crlf) )
    (interrupt)
}

sp {apply*props*retrieve-delta*success*old-delta
    (state <s> ^operator.name props-retrieve-delta
               ^smem <smem>
               ^superstate <ss>
              -^selected-delta)
    (<ss> ^smem.inhibit-list <spl>
          ^props-epset <ep>)
    (<ep> #^const <const>
         #-^generated 
          ^delta <sd>)
    (<sd> ^op-name <dname>)
    (<smem> ^command <scmd>
            ^result.retrieved <d>)
    (<d> ^op-name <dname>)
    (<scmd> ^query <q>)
  -{(<d> ^prop.name <name>)
   -(<ss> ^props-epset.delta.prop.name <name>)}   # It is not the case that it has unintended actions
  -{(<d> ^prop.name <opn>)
    (<ss> ^set-applied.item-name <opn>)}     # It is not the case that it has already-used actions
-->
    (<s> ^selected-delta <d>)
    (<ss> #^props-epset <epnew>
          ^prefer-delta-best <sd>)
    #(<ep> ^delta <sd>)
             #^generated true
             #^const <const>
    (<scmd> ^query <q> -)
    (<spl> ^inhibit <sd>)
}
sp {apply*props*retrieve-delta*success*new-delta
    (state <s> ^operator.name props-retrieve-delta
               ^smem <smem>
               ^superstate <ss>
              -^selected-delta)
    (<ss> ^smem.inhibit-list <spl>
          ^props-epset <ep>)
    (<smem> ^command <scmd>
            ^result.retrieved <d>)
    (<d> ^op-name <dname>
         ^is-combo true)
  -{(<d> ^prop.name <name>)
   -(<ss> ^props-epset.delta.prop.name <name>)}   # It is not the case that it has unintended actions
  -{(<d> ^prop.name <opn>)
    (<ss> ^set-applied.item-name <opn>)}     # It is not the case that it has already-used actions
-->
    (<s> ^selected-delta <d>)
    (<ss> ^prefer-delta-best <d>)
    (<ep> ^delta <d>)
    (<scmd> ^query <q> -)
    #(<spl> ^inhibit <d>)
}

# IF UNSUCCESSFUL RETRIEVE, FIND OUT WHY IN SUBSTATE
sp {apply*props*retrieve-delta*incorrect*unintended*none-okay
    "If the delta has an unintended action, try again."
    (state <s> ^operator.name props-retrieve-delta
               ^smem <smem>
               ^superstate <ss>)
    (<ss> ^props-epset <spe>
          ^smem.inhibit-list <spl>)
    (<smem> ^result.retrieved <d>
            ^command <scmd>)
    (<scmd> ^query <q>)
    (<d> ^op-name <name>)
    -{(<spe> ^delta.prop.name <aname>)
      (<d> ^prop.name <aname>)}
-->
    (<scmd> ^query <q> -)
    (<spl> ^inhibit <d>)
    #(<dcopy> ^op-name <name>)
    #(link-stm-to-ltm <dcopy> (@ <d>))
    (write |  RETRACTING DELTA | <name> |: NO PARTS INTENDED.| (crlf) )
    #(interrupt)
}
sp {apply*props*retrieve-delta*incorrect*unintended*some-okay
    "If the delta has an unintended action, try again."
    (state <s> ^operator.name props-retrieve-delta
               ^smem <smem>
               ^superstate <ss>)
    (<ss> ^props-epset <spe>
          ^smem.inhibit-list.negate <neg>)
    (<smem> ^result.retrieved <d>
            ^command <scmd>)
    (<scmd> ^query <q>)
    (<d> ^prop.name <aname1>
         #^prop.name <aname2>
         ^op-name <name>)
    -(<spe> ^delta.prop.name <aname1>)
     #(<spe> ^delta.prop.name <aname2>)    # It has at least one of the conditions
-->
    (<scmd> ^query <q> -)
    (<neg> ^item-name <aname1>)
    #(force-learn <s>)
    (write |  RETRACTING DELTA | <name> |: | <aname1> | NOT INTENDED.| (crlf) )
    #(interrupt)
}
#sp {elaborate*props*retrieve-delta*incorrect*reused
#    "If the cbset has an alread-used action, try again."
#    (state <s> ^impasse
#               ^superstate <ss>)
#    (<ss> ^impasse tie
#          ^smem <ssmem>
#          ^superstate <sss>)
#    (<sss> ^props-epset.delta.prop.name <aname>
#           ^set-applied.item-name <aname>)
#    (<ssmem> ^result.retrieved <d>
#             ^inhibit-list <spl>)
#    (<d> ^prop.name <aname>
#          ^op-name <name>)
#-->
#    (<s> ^to-negate <neg>)
#    (<neg> ^item-name <aname>)
#    #(<dcopy> ^op-name <name>)
#    #(link-stm-to-ltm <dcopy> (@ <d>)) 
#    #(force-learn <s>)
#    (write |  RETRACTING DELTA | <name> |: | <aname> | ALREADY USED.| (crlf) )
#    #(interrupt)
#}

sp {elaborate*props*retrieve-delta*incorrect*return-negation
    (state <s> ^superstate <ss>
               ^to-negate <neg>)
    (<ss> ^impasse tie
          ^smem.command <sscmd>)
-->
    (<sscmd> ^neg-query <neg>)
}
sp {elaborate*props*retrieve-delta*incorrect*return-inhibit
    (state <s> ^superstate <ss>
               ^to-inhibit <d>)
    (<ss> ^impasse tie
          ^inhibit-list <spl>)
-->
    (<spl> ^inhibit <d>) 
}

# PREFER FETCHED DELTAS
sp {prefer*props*delta-preferred
    (state <s> ^operator <o1> +
               ^prefer-delta-best <d>)
    (<o1> ^delta <d>)
-->
    (<s> ^operator <o1> >)
}

# SUPPLY CACHED ADDRESSES:

sp {elaborate*props*cbset*act*address1*buffer
    (state <s> ^props-cbset.action <a>
               ^topstate.<buff> <buff-id>)
    (<a> ^address1 <buff>
         ^name <aname>)
-->
    (<a> ^id1 <buff-id>)
}
sp {elaborate*props*cbset*act*address2*buffer
    (state <s> ^props-cbset.action <a>
               ^topstate.<buff> <buff-id>)
    (<a> ^address2 <buff>
         ^name <aname>)
-->
    (<a> ^id2 <buff-id>)
}
sp {elaborate*props*cbset*act*address2*const
    (state <s> ^props-cbset.action <a>
               ^props-epset.const <const>)
    (<a> ^address2 |props$const|
         ^name <aname>)
-->
    (<a> ^id2 <const>)
}
sp {elaborate*props*cbset*act*address1*rootstate
    (state <s> ^props-cbset <cb>
               ^topstate <ts>)
    (<cb> ^action <a>)
    (<a> ^address1 |props$rootstate|
         ^name <aname>)
-->
    (<a> ^id1 <ts>)
}
sp {elaborate*props*cbset*act*address2*rootstate
    (state <s> ^props-cbset <cb>
               ^topstate <ts>)
    (<cb> ^action <a>)
    (<a> ^address2 |props$rootstate|
         ^name <aname>)
-->
    (<a> ^id2 <ts>)
}

sp {elaborate*props*cbset*act*address1*missing
    (state <s> ^props-cbset.action <a>
               ^topstate <ts>)
    (<ts> ^io.output-link <ol>
          -^<buff> <buff-id>)
    (<a> ^address1 {<buff> <> |props$rootstate|})
-->
    (<ol> ^error <e>)
    (<e> ^msg (concat |APPLY FAILED - (| <ts> | ^| <buff> | ) missing for id1!|) )
    (write (concat |APPLY FAILED - (| <ts> | ^| <buff> | ) missing for id1!|) (crlf) )
    (interrupt)
}
sp {elaborate*props*cbset*act*address2*missing*buffer
    (state <s> ^props-cbset.action <a>
               ^topstate <ts>)
    (<ts> ^io.output-link <ol>
          -^<buff> <buff-id>)
    (<a> ^address2 {<buff> <> |props$const| <> |props$rootstate|})
-->
    (<ol> ^error <e>)
    (<e> ^msg (concat |APPLY FAILED - (| <ts> | ^| <buff> | ) missing for id2!|) )
    (write (concat |APPLY FAILED - (| <ts> | ^| <buff> | ) missing for id2!|) (crlf) )
    (interrupt)
}

### OPERATOR ### 
# <propose-cbset>
##
# Propose the fetched cbset and copy its action to the return buffer
### 

sp {propose*props*cbset
    (state <s> ^props-cbset <cb>)
    (<cb> ^props-cbset-name <name>)
-->
    (<s> ^operator <o> + >)
    (<o> ^name <name>
         ^cbset <cb>)
}

sp {apply*props*cbset*add*cbset-preferred
    (state <s> ^operator <o>
               #^superstate <ss>)
               ^props-epset.delta <d>
               ^prop-apply-buffer.apply <ba>)
    (<o> ^cbset <cb>)
    (<cb> ^op-name <dname>
          ^props-cbset-name <set>)
    (<d> ^prop <a>
         ^op-name <dname>
         ^cond-id1.id1 <id1>
         ^cond-id2.id2 <id2>)
    (<a> ^prop-type add
         ^name <cname>
         #^id1 <id1>
         #^id2 <id2>
         ^attr1 <attr1>
         ^attr2 <attr2>)
    (<id2> ^<attr2> <val>)
-->
    (<ba> ^delta-action <dnew>)
    (<dnew> ^prop-type add
            ^name <cname>
            ^id1 <id1>
            ^attr1 <attr1>
            ^val <val>)
    (<s> ^set-applied <anew>)
    (<anew> ^item-name <dname>
            ^set-name <set>)
}
sp {apply*props*cbset*remove*cbset-preferred
    (state <s> ^operator <o>
               #^superstate <ss>)
               ^props-epset.delta <d>
               ^prop-apply-buffer.apply <ba>)
    (<o> ^cbset <cb>)
    (<cb> ^op-name <dname>
          ^props-cbset-name <set>)
    (<d> ^prop <a>
         ^op-name <dname>
         ^cond-id1.id1 <id1>)
    (<a> ^prop-type remove
         ^name <cname>
         ^id1 <id1>
         ^attr1 <attr1>)
-->
    (<ba> ^delta-action <dnew>)
    (<dnew> ^prop-type remove
            ^name <cname>
            ^id1 <id1>
            ^attr1 <attr1>)
    (<s> ^set-applied <anew>)
    (<anew> ^item-name <dname>
            ^set-name <set>)
}

sp {apply*props*cbset*clear-applied
    (state <s> ^operator.cbset <cb>)
               #^superstate <ss>)
               #^props-cbset <cb>)
    (<cb> ^props-cbset-name <setname>)
  -{(<cb> ^op-name <dname>)
    (<s> -^set-applied.item-name <dname>)} # It is not the case that there is an action that is not yet applied
-->
    (<s> ^props-cbset <cb> - )
    (<s> ^combine-cbset <setname>)
}


### OPERATOR ### 
# props-cbsets-combine
##
# Combine pairs of separate cbsets used
### 

sp {elaborate*props*cbsets*combine-done
    "Mark when the hierarchy of combinations is complete"
    (state <s> ^combine-cbset <n1>
              -^combine-cbset <> <n1>
              -^props-flag epset-incomplete)
  -(<s> ^operator.name props-cbsets-combine) # Wait until operator completes, proposal phase only
-->
    (<s> ^cbset-combine-done skipped)
}

#sp {propose*props*cbsets-combine
#    (state <s> ^combine-cbset <name>
#              -^props-cbset 
#              -^cbset-combine-done )
#-->
#    (<s> ^operator <o> + < =)
#    (<o> ^name props-cbsets-combine)
#}

sp {apply*props*cbsets-combine*new-sets
    (state <s> ^operator.name props-cbsets-combine
               ^combine-cbset <n1>
               ^combine-cbset {<n2> < <n1>})
-->
    (<s> ^new-delta <cnew>)
    (<cnew> ^source-cbset <n1>
            ^source-cbset <n2>
            ^op-name (concat <n1> <n2>))
}
sp {apply*props*cbsets-combine*collect-actions
    (state <s> ^operator.name props-cbsets-combine
               ^props-epset <pe>
               ^new-delta <combo>)
    (<pe> ^delta <app>)
    (<app> ^op-name <src1>
           ^prop <c>)
    (<c> ^name <cname>)
    (<combo> ^source-cbset <src1>)
-->
    (<combo> ^prop <c>
             ^item-name <cname>) # Include so neg-queries can test it
}
sp {apply*props*cbsets-combine*link
    (state <s> ^operator.name props-cbsets-combine
               ^props-epset <pe>
               ^new-delta <dnew>)
    (<pe> ^delta <d1>
          ^delta <d2>
         -^generated)
    (<d1> ^op-name <src1>)
    (<d2> ^op-name <src2>)
    (<dnew> ^source-cbset <src1>
             ^source-cbset {<src2> > <src1>}
             ^op-name <comboname>)
-->
    (<dnew> ^source-cbset <src1> -
            ^source-cbset <src2> -
            ^prop-apply <comboname>
            ^is-combo true)
    # Make spreading struct from epset to new cbset 
    (<d1> ^spread-link <dnew>)
    (<d2> ^spread-link <dnew>)
    (<s> ^props-to-store <d1>
         ^props-to-store <d2>
         ^props-to-store <dnew>
         ^props-flag to-store-waiting    # An optimization to avoid combinatorial rule firing in cbsets-combine*done.
         ^no-propose <d1>
         ^no-propose <d2>)        # Retract the id info from the deltas so it doesn't get stored
#         ^new-delta <c> -
#         ^set-applied <sa> -)    # Could remove, but might actually be less efficient since state about to blow away anyway
}
sp {apply*props*cbsets-combine*store
    (state <s> ^operator.name props-cbsets-combine
               ^smem.command <scmd>
               ^props-to-store <new>
               ^props-flag to-store-waiting)
-->
    (<scmd> ^store <new>)
    (<s> ^props-to-store <new> -
         ^props-flag to-store-waiting -)
}
sp {apply*props*cbsets-combine*done
    "Once store is requested remove combine objects and report finished"
    (state <s> ^operator.name props-cbsets-combine
               ^props-flag to-store-waiting
               ^combine-cbset <cname>)
-->
    (<s> ^combine-cbset <cname> -
         ^cbset-combine-done true)
}

# CHUNK THE MAIN STATE IF THIS IS THE LAST COMBO
sp {apply*props*cbsets-combine*final-combo
    (state <s> ^operator.name props-cbsets-combine
               ^superstate.operator.name <oname>
               ^new-delta <c1>
              -^new-delta <> <c1>)
-->
    (force-learn <s>)
    (write |*** WILL LEARN OP: | <oname> (crlf) )
    #(interrupt)
}

### APPLY BUFFER ###

sp {elaborate*props*buffer-staging*dest-id
    "Compile record of ids referenced (for object bundling)"
    (state <s> ^prop-apply-buffer.apply <ba>
               ^superstate nil)
    (<ba> ^delta-action <da>)
    (<da> ^prop-type add
          ^id1 <id>)
-->
    (<ba> ^dest-id <id>)
}


## WHEN ALL ACTIONS ARE STAGED, RETURN THEM
sp {elaborate*props*apply-buffer*nonempty
    (state <s> ^prop-apply-buffer.apply.delta-action <any>)
-->
    (<s> ^props-flag apply-buffer-nonempty)
}
sp {elaborate*props*epset-incomplete
    (state <s> ^prop-apply-buffer <b>
               ^props-epset <pe>)
    (<pe> ^<< apply delta >>.name <pname>)
    (<b> -^apply.delta-action.name <pname>)
-->
    (<s> ^props-flag epset-incomplete)
}
#sp {elaborate*props*epset*return
#    (state <s> ^prop-apply-buffer <b>
#               ^props-flag apply-buffer-nonempty
#              -^props-flag epset-incomplete
#               ^cbset-combine-done true
#               ^superstate <ss>
#               ^props-epset <pe>)
#    (<ss> ^operator.delta
#          ^prop-apply-buffer <sb>)
#  -{(<pe> ^delta.prop.name <cname>)
#    (<b> -^apply.delta-action.name <cname>)}    # It is not the case that an operator delta has not been staged
#-->
#    (<sb> ^apply <b>)
#    (<b> ^dc-stamp (dc))
#}
sp {propose*props*epset-return
    (state <s> ^prop-apply-buffer <b>
               ^props-flag apply-buffer-nonempty
              #-^props-flag epset-incomplete
               #^cbset-combine-done <ccd-any>    # << true skipped >>
               ^superstate.operator.delta # For chunk condition
               ^props-epset <pe>)
  -{(<pe> ^delta.prop.name <cname>)
    (<b> -^apply.delta-action.name <cname>)}    # It is not the case that an operator delta has not been staged
-->
    (<s> ^operator <o> +)
    (<o> ^name props-epset-return)
}
sp {apply*props*epset-return
    (state <s> ^operator.name props-epset-return
               ^topstate <> <ss>
               ^superstate <ss>)
    (<ss> ^prop-apply-buffer.apply <sba>)
-->
    (<sba> ^dc-stamp (dc))
}
sp {apply*props*epset-return*delta-action
    (state <s> ^operator.name props-epset-return
               ^prop-apply-buffer.apply.delta-action <da>
               ^topstate <> <ss>
               ^superstate <ss>)
    (<ss> ^prop-apply-buffer.apply <sba>)
-->
    (<sba> ^delta-action <da>)
}
sp {apply*props*epset-return*to-topstate
    "When finished composing actions, simply return the apply buffer."
    (state <s> ^operator.name props-epset-return
               ^prop-apply-buffer.apply <pa>
               ^topstate <ss>
               ^superstate <ss>)
    (<ss> ^prop-apply-buffer <sb>)
-->
    (<sb> ^apply <pa>)
    (write | | (crlf) (crlf))
}

sp {set*apply-buffer*trim-dc-stamp
    "Remove old dc-stamps within the same apply struct"
    :o-support
    (state <s> ^prop-apply-buffer.apply <pa>)
    (<pa> ^dc-stamp <dc1>
          ^dc-stamp > <dc1>)
-->
    (<pa> ^dc-stamp <dc1> -)
}

#sp {elaborate*props*epset-return*cascade
#    "Return finished applications for chunking and superstate application."
#    (state <s> ^prop-apply-buffer <b>
#               ^superstate.prop-apply-buffer <sb>
#               ^props-epset <pe>)
#    (<b> ^apply <ba>)
#    (<ba> ^dc-stamp )
#    -{(<pe> ^delta.prop.name <cname>)
#      (<b> -^apply.delta-action.name <cname>)}
#-->
#    (<sb> ^apply <ba>)
#}

#sp {elaborate*props*epset-return*force-learn
#    (state <s> ^operator <o1> +
#               ^cbset-combine-done skipped
#               ^superstate.operator.name <oname>)
#    (<o1> ^name props-epset-return)
#-->
#    (force-learn <s>)
#    (write |*** WILL LEARN OP: | <oname> (crlf) )
#    #(interrupt)
#}

# Implement locks
sp {elaborate*props*apply-buffer*locks
    "For each apply, lock the slot from perceptual interference"
    (state <s> ^prop-apply-buffer.apply <ba>
               ^locks <locks>
               ^superstate nil)
    (<ba> ^delta-action <da>
          ^dc-stamp )
    (<da> ^id1 <id1>
          ^attr1 <attr1>)
   -(<id1> ^props-agnostic-add true)    # Bundled object creation doesn't lock
-->
    (<locks> ^lock <knew>)
    (<knew> ^id1 <id1>
            ^attr1 <attr1>)
}

#sp {apply*props*apply-buffer*overwrite
#    "If new apply uses previously locked slots, remove old competing apply"
#    (state <s> ^prop-apply-buffer <b>
#               ^operator <oany>)
#    (<b> ^apply <b1>
#         ^apply <b2>)
#    (<b1> ^delta-action <d1any>
#          ^dc-stamp <dc>)
#    (<b2> ^delta-action <d2any>
#          ^dc-stamp < <dc>)    # <b2> is older
#    (<d1any> ^id1 <id>
#             ^attr1 <attr>)
#    (<d2any> ^id1 <id>         # they share a target address
#             ^attr1 <attr>)
#-->
#    (<b> ^apply <b2> -)
#} # Use this rule if assuming joint actions share support, not independent
sp {set*props*apply-buffer*overwrite
    "If new apply uses previously locked slots, remove old competing apply"
    :o-support
    (state <s> ^prop-apply-buffer <b>)
    (<b> ^apply <b1>
         ^apply {<b2> <> <b1>})
    (<b1> ^delta-action <d1any>
          ^dc-stamp <dc>)
    (<b2> ^delta-action <d2any>
          ^dc-stamp > <dc>)    # <b1> is older
    (<d1any> ^id1 <id>
             ^attr1 <attr>)
    (<d2any> ^id1 <id>         # they share a target address
             ^attr1 <attr>)
-->
    (<b1> ^delta-action <d1any> -)
}
sp {set*props*apply-buffer*remove-empty
    "Clean up if all delta-actions for apply are gone from overwriting"
    :o-support
    (state <s> ^prop-apply-buffer <b>)
    (<b> ^apply <b1>)
    (<b1> -^delta-action 
          ^dc-stamp <dc>)
-->
    (<b> ^apply <b1> -)
}


# Elaborate deltas from the apply buffer onto WM
# (Not including operator proposal/preference actions.
#  In this context those are considered architectural.)

sp {elaborate*props*apply-delta*add
    (state <s> ^prop-apply-buffer.apply <pa>
               ^superstate nil)
    (<pa> ^delta-action <d>)
    (<d> ^name <cname>
         ^prop-type add
         ^id1 <id1>
         ^attr1 <attr1>
         ^val <val>)
   -(<id1> ^props-agnostic-add true) # Don't add directly for bundled object actions
-->
    (<id1> ^<attr1> <val>)
}
sp {elaborate*props*apply-delta*remove
    (state <s> ^prop-apply-buffer.apply <pa>
               ^superstate nil)
    (<pa> ^delta-action <d>)
    (<d> ^name <cname>
         ^prop-type remove
         ^id1 <id1>
         ^attr1 <attr1>)
-->
    (<id1> ^<attr1> <val> -)
}

# Special case: adding object clusters/commands; make o-supported without apply-buffer support
sp {set*props*apply-delta*add-object
    "Add object for bundling created wmes from this apply"
    :o-support
    (state <s> ^prop-apply-buffer.apply <pa>
               ^superstate nil)
    (<pa> ^dest-id <id>
          ^dc-stamp <dc>)
    (<id> ^props-agnostic-add true)
-->
    (<id> ^object <jnew>)
    (<jnew> ^dc-stamp <dc>)
}
sp {set*props*apply-delta*add-object-aug
    "Add augmentation for bundled object from this apply"
    :o-support
    (state <s> ^prop-apply-buffer.apply <pa>)
    (<pa> ^delta-action <d>
          ^dest-id <id1>
          ^dc-stamp <dc>)
    (<d> ^prop-type add
         ^id1 <id1>
         ^attr1 <attr1>
         ^val <val>)
    (<id1> ^props-agnostic-add true
           ^object <obj>)
    (<obj> ^dc-stamp <dc>)
-->
    (<obj> ^<attr1> <val>)
    (<pa> ^delta-action <d> -)
}

# Special case: if a WM aug was created via newWM, then it has o-support and needs to be removed explicitly when a locking action is made
sp {set*props*apply-delta*remove-old
    :o-support
    (state <s> ^prop-apply-buffer <pab>
               ^superstate nil)
    (<pab> ^apply.delta-action <d>)
    (<d> ^name <cname>
         ^prop-type add
         ^id1 <id1>
         ^attr1 <attr1>
         ^val <val>)
    -{(<pab> ^apply.delta-action <d2>)
      (<d2> ^id1 <id1>
            ^attr1 <attr1>
            ^val <vold>) }
    (<id1> ^<attr1> {<vold> <> <val>})
-->
    (<id1> ^<attr1> <vold> -)
}

#sp {set*props*apply-delta*add-object*cond-done
#    "Mark actions that make object augs as done on use, so not proposed again (for efficiency only)"
#    :o-support
#    (state <s> ^prop-apply-buffer.apply <pa>
#               ^props-epset.delta <d>)
#    (<pa> ^dest-id <id>
#          ^dc-stamp <dc>)
#    (<id> ^props-agnostic-add true
#          ^object <obj>)
#    (<obj> ^dc-stamp <dc>)
#    (<d> ^prop <c>)
#    (<c> ^address1 <id>
#         ^prop-type add)
#-->
#    (<d> ^no-propose true)
#} # FIXME: Doesn't work as intended. See notes: 11/7/18

sp {catch*props*failure*epset-return
    (state <s> ^impasse no-change
               ^attribute state
               ^topstate.io.output-link <ol>
               ^superstate <ss>) 
-->
    #(<rs> ^operator <o> + > !)
    #(<o> ^name props-fetch-reset)
    (write (cmd print <ss> -d 4))
    (write (cmd preferences <ss> operator --names))
    (<ol> ^error <e>)
    (<e> ^msg |EPSET NOT RETURNING| )
    (interrupt)
}